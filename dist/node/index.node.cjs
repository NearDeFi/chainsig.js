'use strict';var base=require('@scure/base'),elliptic=require('elliptic'),jsSha3=require('js-sha3'),viem=require('viem'),f=require('bitcoinjs-lib'),Mt=require('coinselect'),amino=require('@cosmjs/amino'),crypto=require('@cosmjs/crypto'),encoding=require('@cosmjs/encoding'),protoSigning=require('@cosmjs/proto-signing'),stargate=require('@cosmjs/stargate'),bech32=require('bech32'),signing=require('cosmjs-types/cosmos/tx/signing/v1beta1/signing'),tx=require('cosmjs-types/cosmos/tx/v1beta1/tx'),chainRegistry=require('chain-registry'),web3_js=require('@solana/web3.js'),accounts=require('@near-js/accounts'),crypto$1=require('@near-js/crypto'),keystores=require('@near-js/keystores'),te=require('bn.js'),transactions=require('@near-js/transactions'),nearApiJs=require('near-api-js'),providers=require('near-api-js/lib/providers');function _interopDefault(e){return e&&e.__esModule?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var n=Object.create(null);if(e){Object.keys(e).forEach(function(k){if(k!=='default'){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:true,get:function(){return e[k]}});}})}n.default=e;return Object.freeze(n)}var f__namespace=/*#__PURE__*/_interopNamespace(f);var Mt__default=/*#__PURE__*/_interopDefault(Mt);var te__default=/*#__PURE__*/_interopDefault(te);var Bt=Object.defineProperty;var m=(r,t)=>{for(var e in t)Bt(r,e,{get:t[e],enumerable:true});};var ut={};m(ut,{CONTRACT_ADDRESSES:()=>q,ENVS:()=>b,KDF_CHAIN_ID:()=>E,ROOT_PUBLIC_KEYS:()=>J});var b={TESTNET_DEV:"TESTNET_DEV",TESTNET:"TESTNET",MAINNET:"MAINNET"},J={[b.TESTNET_DEV]:"secp256k1:placeholder",[b.TESTNET]:"secp256k1:4NfTiv3UsGahebgTaHyD9vF8KYKMBnfd6kh94mK6xv8fGBiJB8TBtFMP5WWXz6B89Ac1fbpzPwAvoyQebemHFwx3",[b.MAINNET]:"secp256k1:3tFRbMqmoa6AAALMrEFAYCEoHcqKxeW38YptwowBVBtXK1vo36HDbUWuR6EZmoK4JcH6HDkNMGGqP1ouV7VZUWya"},E="0x18d",q={[b.TESTNET_DEV]:"v1.signer",[b.TESTNET]:"v1.signer-prod.testnet",[b.MAINNET]:"v1.sig-net.near"};var mt={};m(mt,{cryptography:()=>y});var y={};m(y,{compressPubKey:()=>kt,deriveChildPublicKey:()=>_t,najToUncompressedPubKeySEC1:()=>v,toRSV:()=>Kt});var Kt=r=>{if("big_r"in r&&typeof r.big_r=="object"&&"affine_point"in r.big_r&&"s"in r&&typeof r.s=="object"&&"scalar"in r.s)return {r:r.big_r.affine_point.substring(2),s:r.s.scalar,v:r.recovery_id+27};if("big_r"in r&&typeof r.big_r=="string"&&"s"in r&&typeof r.s=="string")return {r:r.big_r.substring(2),s:r.s,v:r.recovery_id+27};if("bigR"in r&&"x"in r.bigR&&"s"in r&&typeof r.s=="bigint")return {r:r.bigR.x.toString(16).padStart(64,"0"),s:r.s.toString(16).padStart(64,"0"),v:r.recoveryId+27};throw new Error("Invalid signature format")},kt=r=>{let t=r.slice(2);if(t.length!==128)throw new Error("Invalid uncompressed public key length");let e=t.slice(0,64),n=t.slice(64);return (parseInt(n.slice(-1),16)%2===0?"02":"03")+e},v=r=>{let t=base.base58.decode(r.split(":")[1]);return `04${Buffer.from(t).toString("hex")}`};function _t(r,t,e="",n){let a=new elliptic.ec("secp256k1"),i=`sig.network v1.0.0 epsilon derivation,${n},${t},${e}`,o="";if(n===E)o=jsSha3.sha3_256(i);else throw new Error("Invalid chain ID");let c=r.substring(2,66),p=r.substring(66),u=a.curve.point(c,p),d=a.g.mul(o),w=u.add(d),h=w.getX().toString("hex").padStart(64,"0"),B=w.getY().toString("hex").padStart(64,"0");return `04${h}${B}`}var nt={};m(nt,{ChainAdapter:()=>g,btc:()=>k,cosmos:()=>R,evm:()=>A,solana:()=>et});var g=class{};var A={};m(A,{EVM:()=>F,fetchEVMFeeProperties:()=>M});async function M(r,t){let[e,n]=await Promise.all([r.estimateGas(t),r.estimateFeesPerGas()]),a=n.maxFeePerGas??BigInt(1e10),s=n.maxPriorityFeePerGas??BigInt(1e10);return {gas:e,maxFeePerGas:a,maxPriorityFeePerGas:s}}var F=class extends g{constructor({publicClient:t,contract:e}){super(),this.contract=e,this.client=t;}async attachGasAndNonce(t){let e=await M(this.client,t),n=await this.client.getTransactionCount({address:t.from}),{from:a,...s}=t;return {...e,nonce:n,chainId:Number(await this.client.getChainId()),type:"eip1559",...s}}transformRSVSignature(t){return {r:`0x${t.r}`,s:`0x${t.s}`,yParity:t.v-27}}assembleSignature(t){let{r:e,s:n,yParity:a}=this.transformRSVSignature(t);if(a===void 0)throw new Error("Missing yParity");return viem.concatHex([e,n,viem.numberToHex(a+27,{size:1})])}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let a=n.startsWith("04")?n.slice(2):n,s=viem.keccak256(Buffer.from(a,"hex"));return {address:viem.getAddress(`0x${s.slice(-40)}`),publicKey:n}}async getBalance(t){return {balance:await this.client.getBalance({address:t}),decimals:18}}serializeTransaction(t){return viem.serializeTransaction(t)}deserializeTransaction(t){return viem.parseTransaction(t)}async prepareTransactionForSigning(t){let e=await this.attachGasAndNonce(t),n=viem.serializeTransaction(e),a=viem.toBytes(viem.keccak256(n));return {transaction:e,hashesToSign:[Array.from(a)]}}async prepareMessageForSigning(t){return {hashToSign:Array.from(viem.toBytes(viem.hashMessage(t)))}}async prepareTypedDataForSigning(t){return {hashToSign:Array.from(viem.toBytes(viem.hashTypedData(t)))}}async prepareUserOpForSigning(t,e,n){let a=n??await this.client.getChainId(),s=e||"0x0000000071727De22E5E9d8BAf0edAc6f37da032",i=viem.encodeAbiParameters([{type:"bytes32"},{type:"address"},{type:"uint256"}],[viem.keccak256(viem.encodeAbiParameters([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"}],[t.sender,viem.hexToBigInt(t.nonce),viem.keccak256("factory"in t&&"factoryData"in t&&t.factory&&t.factoryData?viem.concat([t.factory,t.factoryData]):"initCode"in t?t.initCode:"0x"),viem.keccak256(t.callData),viem.concat([viem.pad(t.verificationGasLimit,{size:16}),viem.pad(t.callGasLimit,{size:16})]),viem.hexToBigInt(t.preVerificationGas),viem.concat([viem.pad(t.maxPriorityFeePerGas,{size:16}),viem.pad(t.maxFeePerGas,{size:16})]),viem.keccak256("paymaster"in t&&t.paymaster&&viem.isAddress(t.paymaster)?viem.concat([t.paymaster,viem.pad(t.paymasterVerificationGasLimit,{size:16}),viem.pad(t.paymasterPostOpGasLimit,{size:16}),t.paymasterData]):"paymasterAndData"in t?t.paymasterAndData:"0x")])),s,BigInt(a)]),o=viem.keccak256(i);return {userOp:t,hashToSign:Array.from(viem.toBytes(viem.hashMessage({raw:o})))}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){let n=this.transformRSVSignature(e[0]);return viem.serializeTransaction(t,n)}finalizeMessageSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeTypedDataSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeUserOpSigning({userOp:t,rsvSignature:e}){let{r:n,s:a,yParity:s}=this.transformRSVSignature(e);if(s===void 0)throw new Error("Missing yParity");return {...t,signature:viem.concatHex(["0x00",n,a,viem.numberToHex(Number(s+27),{size:1})])}}async broadcastTx(t){try{return {hash:await this.client.sendRawTransaction({serializedTransaction:t})}}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var k={};m(k,{BTCRpcAdapter:()=>S,BTCRpcAdapters:()=>$,Bitcoin:()=>z});function Q(r){switch(r.toLowerCase()){case "mainnet":return f__namespace.networks.bitcoin;case "testnet":return f__namespace.networks.testnet;case "regtest":return f__namespace.networks.regtest;default:throw new Error(`Unknown Bitcoin network: ${r}`)}}var z=class r extends g{static{this.SATOSHIS_PER_BTC=1e8;}constructor({network:t,contract:e,btcRpcAdapter:n}){super(),this.network=t,this.btcRpcAdapter=n,this.contract=e;}static toBTC(t){return t/r.SATOSHIS_PER_BTC}static toSatoshi(t){return Math.round(t*r.SATOSHIS_PER_BTC)}async fetchTransaction(t){let e=await this.btcRpcAdapter.getTransaction(t),n=new f__namespace.Transaction;return e.vout.forEach(a=>{let s=Buffer.from(a.scriptpubkey,"hex");n.addOutput(s,Number(a.value));}),n}static transformRSVSignature(t){let e=t.r.padStart(64,"0"),n=t.s.padStart(64,"0"),a=Buffer.from(e+n,"hex");if(a.length!==64)throw new Error("Invalid signature length.");return a}async createPSBT({transactionRequest:t}){let{inputs:e,outputs:n}=t.inputs&&t.outputs?t:await this.btcRpcAdapter.selectUTXOs(t.from,[{address:t.to,value:parseFloat(t.value)}]),a=new f__namespace.Psbt({network:Q(this.network)});return await Promise.all(e.map(async s=>{if(!s.scriptPubKey){let o=(await this.fetchTransaction(s.txid)).outs[s.vout];s.scriptPubKey=o.script;}a.addInput({hash:s.txid,index:s.vout,witnessUtxo:{script:s.scriptPubKey,value:s.value}});})),n.forEach(s=>{"address"in s?a.addOutput({address:s.address,value:s.value}):"script"in s?a.addOutput({script:s.script,value:s.value}):t.from!==void 0&&a.addOutput({value:Number(s.value),address:t.from});}),a}async getBalance(t){return {balance:BigInt(await this.btcRpcAdapter.getBalance(t)),decimals:8}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let a=y.compressPubKey(n),s=Buffer.from(a,"hex"),i=Q(this.network),o=f__namespace.payments.p2wpkh({pubkey:s,network:i}),{address:c}=o;if(!c)throw new Error("Failed to generate Bitcoin address");return {address:c,publicKey:a}}serializeTransaction(t){return JSON.stringify({psbt:t.psbt.toHex(),publicKey:t.publicKey})}deserializeTransaction(t){let e=JSON.parse(t);return {psbt:f__namespace.Psbt.fromHex(e.psbt),publicKey:e.publicKey}}async prepareTransactionForSigning(t){let e=Buffer.from(t.publicKey,"hex"),n=await this.createPSBT({transactionRequest:t}),a=n.toHex(),s=[],i=o=>({publicKey:e,sign:c=>(s[o]=Array.from(c),Buffer.alloc(64))});for(let o=0;o<n.inputCount;o++)n.signInput(o,i(o));return {transaction:{psbt:f__namespace.Psbt.fromHex(a),publicKey:t.publicKey},hashesToSign:s}}finalizeTransactionSigning({transaction:{psbt:t,publicKey:e},rsvSignatures:n}){let a=Buffer.from(e,"hex"),s=i=>({publicKey:a,sign:()=>{let o=n[i];return r.transformRSVSignature(o)}});for(let i=0;i<t.inputCount;i++)t.signInput(i,s(i));return t.finalizeAllInputs(),t.extractTransaction().toHex()}async broadcastTx(t){return {hash:await this.btcRpcAdapter.broadcastTransaction(t)}}};var S=class{};var K=class extends S{constructor(t){super(),this.providerUrl=t;}async fetchFeeRate(t=6){let n=await(await fetch(`${this.providerUrl}/v1/fees/recommended`)).json();return t<=1?n.fastestFee:t<=3?n.halfHourFee:t<=6?n.hourFee:n.economyFee}async fetchUTXOs(t){try{return await(await fetch(`${this.providerUrl}/address/${t}/utxo`)).json()}catch(e){return console.error("Failed to fetch UTXOs:",e),[]}}async selectUTXOs(t,e,n=6){let a=await this.fetchUTXOs(t),s=await this.fetchFeeRate(n),i=Mt__default.default(a,e,Math.ceil(s+1));if(!i.inputs||!i.outputs)throw new Error("Invalid transaction: coinselect failed to find a suitable set of inputs and outputs. This could be due to insufficient funds, or no inputs being available that meet the criteria.");return {inputs:i.inputs,outputs:i.outputs}}async broadcastTransaction(t){let e=await fetch(`${this.providerUrl}/tx`,{method:"POST",body:t});if(e.ok)return await e.text();throw new Error(`Failed to broadcast transaction: ${await e.text()}`)}async getBalance(t){let n=await(await fetch(`${this.providerUrl}/address/${t}`)).json();return n.chain_stats.funded_txo_sum-n.chain_stats.spent_txo_sum}async getTransaction(t){return await(await fetch(`${this.providerUrl}/tx/${t}`)).json()}};var $={Mempool:K};var R={};m(R,{Cosmos:()=>G});var bt=async r=>{let t=chainRegistry.chains.find(d=>d.chain_id===r);if(!t)throw new Error(`Chain info not found for chainId: ${r}`);let{bech32_prefix:e,chain_id:n}=t,a=t.staking?.staking_tokens?.[0]?.denom,s=t.apis?.rpc?.[0]?.address,i=t.apis?.rest?.[0]?.address,o=t.fees?.fee_tokens?.[0]?.average_gas_price;if(!e||!a||!s||!i||!n||o===void 0)throw new Error(`Missing required chain information for ${t.chain_name}`);let p=chainRegistry.assets.find(d=>d.chain_name===t.chain_name)?.assets.find(d=>d.base===a),u=p?.denom_units.find(d=>d.denom===p.display)?.exponent;if(u===void 0)throw new Error(`Could not find decimals for ${a} on chain ${t.chain_name}`);return {prefix:e,denom:a,rpcUrl:s,restUrl:i,expectedChainId:n,gasPrice:o,decimals:u}};var G=class extends g{constructor({chainId:t,contract:e,endpoints:n}){super(),this.contract=e,this.registry=new protoSigning.Registry,this.chainId=t,this.endpoints=n;}transformRSVSignature(t){return new Uint8Array([...encoding.fromHex(t.r),...encoding.fromHex(t.s)])}async getChainInfo(){return {...await bt(this.chainId),...this.endpoints}}async getBalance(t){try{let{restUrl:e,denom:n,decimals:a}=await this.getChainInfo(),s=await fetch(`${e}/cosmos/bank/v1beta1/balances/${t}`);if(!s.ok)throw new Error(`HTTP error! status: ${s.status}`);let c=(await s.json()).balances.find(p=>p.denom===n)?.amount??"0";return {balance:BigInt(c),decimals:a}}catch(e){throw console.error("Failed to fetch Cosmos balance:",e),new Error("Failed to fetch Cosmos balance")}}async deriveAddressAndPublicKey(t,e){let{prefix:n}=await this.getChainInfo(),a=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!a)throw new Error("Failed to get derived public key");let s=y.compressPubKey(a),i=crypto.sha256(encoding.fromHex(s)),o=crypto.ripemd160(i);return {address:bech32.bech32.encode(n,bech32.bech32.toWords(o)),publicKey:s}}serializeTransaction(t){let e=tx.TxRaw.encode(t).finish();return encoding.toBase64(e)}deserializeTransaction(t){return tx.TxRaw.decode(encoding.fromBase64(t))}async prepareTransactionForSigning(t){let{denom:e,rpcUrl:n,gasPrice:a}=await this.getChainInfo(),s=encoding.fromHex(t.publicKey),i=t.gas||2e5,o=stargate.calculateFee(i,stargate.GasPrice.fromString(`${a}${e}`)),p=await(await stargate.StargateClient.connect(n)).getAccount(t.address);if(!p)throw new Error(`Account ${t.address} does not exist on chain`);let{accountNumber:u,sequence:d}=p,w={typeUrl:"/cosmos.tx.v1beta1.TxBody",value:{messages:t.messages,memo:t.memo||""}},h=this.registry.encode(w),B=protoSigning.encodePubkey(amino.encodeSecp256k1Pubkey(s)),N=protoSigning.makeAuthInfoBytes([{pubkey:B,sequence:d}],o.amount,Number(o.gas),void 0,void 0,signing.SignMode.SIGN_MODE_DIRECT),W=protoSigning.makeSignDoc(h,N,this.chainId,u),Y=protoSigning.makeSignBytes(W),V=Array.from(crypto.sha256(Y));return {transaction:tx.TxRaw.fromPartial({bodyBytes:h,authInfoBytes:N,signatures:[]}),hashesToSign:[V]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){t.signatures=e.map(a=>this.transformRSVSignature(a));let n=tx.TxRaw.encode(t).finish();return Buffer.from(n).toString("hex")}async broadcastTx(t){try{let{rpcUrl:e}=await this.getChainInfo(),n=await stargate.StargateClient.connect(e),a=encoding.fromHex(t),s=await n.broadcastTx(a);if(s.code!==0)throw new Error(`Broadcast error: ${s.rawLog}`);return s.transactionHash}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var et={};m(et,{Solana:()=>tt});var Qt=r=>typeof r=="bigint"?r:BigInt(r.toString()),tt=class extends g{constructor(t){super(),this.connection=t.solanaConnection,this.contract=t.contract;}async getBalance(t){let e=new web3_js.PublicKey(t),n=await this.connection.getBalance(e);return {balance:BigInt(n),decimals:9}}async deriveAddressAndPublicKey(t,e){let a=(await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true})).replace("ed25519:",""),s=new web3_js.PublicKey(a);return {address:s.toBase58(),publicKey:s.toString()}}serializeTransaction(t){return Buffer.from(t.transaction.serialize({requireAllSignatures:false})).toString("base64")}deserializeTransaction(t){let e=Buffer.from(t,"base64"),n=web3_js.Transaction.from(e);return {transaction:n,feePayer:n.feePayer||new web3_js.PublicKey("11111111111111111111111111111111"),recentBlockhash:n.recentBlockhash||""}}async prepareTransactionForSigning(t){let e=new web3_js.Transaction,n=Qt(t.amount);n>0n&&e.add(web3_js.SystemProgram.transfer({fromPubkey:new web3_js.PublicKey(t.from),toPubkey:new web3_js.PublicKey(t.to),lamports:Number(n)})),t.instructions&&e.add(...t.instructions);let{blockhash:a}=await this.connection.getLatestBlockhash();e.recentBlockhash=a,e.feePayer=t.feePayer||new web3_js.PublicKey(t.from);let s=e.compileMessage().serialize();return {transaction:{transaction:e,feePayer:e.feePayer,recentBlockhash:a},hashesToSign:[Array.from(s)]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e,senderAddress:n}){let a=Buffer.from(e.signature);return t.addSignature(new web3_js.PublicKey(n),a),t.serialize().toString("base64")}async broadcastTx(t){let e=this.deserializeTransaction(t);return {hash:await this.connection.sendRawTransaction(e.transaction.serialize())}}};var It={};m(It,{ChainSignatureContract:()=>x,near:()=>pt});var rt=class{},x=class extends rt{};var pt={};m(pt,{ChainSignatureContract:()=>l,utils:()=>Se});var ct={};m(ct,{keypair:()=>ot});var ot={};m(ot,{BTCTransaction:()=>be,CosmosTransaction:()=>Te,EVMTransaction:()=>fe});var L=new te__default.default("300000000000000"),U="dontcare";var I=async({networkId:r,accountId:t=U,keypair:e=crypto$1.KeyPair.fromRandom("ed25519")})=>{let n=new keystores.InMemoryKeyStore;await n.setKey(r,t,e);let a=accounts.Connection.fromConfig({networkId:r,provider:{type:"JsonRpcProvider",args:{url:{testnet:"https://rpc.testnet.near.org",mainnet:"https://rpc.mainnet.near.org"}[r]}},signer:{type:"InMemorySigner",keyStore:n}});return new accounts.Account(a,t)};var Pt=r=>{let t=Object.entries(q).find(([e,n])=>n.toLowerCase()===r.toLowerCase())?.[0];if(t)return J[t]};var it={};m(it,{mpcPayloadsToChainSigTransaction:()=>de,responseToMpcSignature:()=>at,sendTransactionUntil:()=>st});var de=async({networkId:r,contractId:t,hashesToSign:e,path:n})=>{let s=await new l({networkId:r,contractId:t}).getCurrentSignatureDeposit();return {receiverId:t,actions:e.map(i=>({type:"FunctionCall",params:{methodName:"sign",args:{request:{payload:Array.from(i),path:n,key_version:0}},gas:L.div(new te__default.default(e.length)).toString(),deposit:s?.toString()||"1"}}))}},at=({response:r})=>{let t=providers.getTransactionLastResult(r);if(t)return y.toRSV(t)},st=async({accountId:r,keypair:t,networkId:e,receiverId:n,actions:a,nonce:s,options:i={until:"EXECUTED_OPTIMISTIC",retryCount:3,delay:5e3,nodeUrl:e==="testnet"?"https://test.rpc.fastnear.com":"https://free.rpc.fastnear.com"}})=>{let o=new keystores.InMemoryKeyStore;await o.setKey(e,r,t);let c=await nearApiJs.connect({networkId:e,keyStore:o,nodeUrl:i.nodeUrl}),{signer:p}=c.connection,u=await p.getPublicKey(r,c.connection.networkId),d=await c.connection.provider.query(`access_key/${r}/${u.toString()}`,""),w=nearApiJs.utils.serialize.base_decode(d.block_hash),h=nearApiJs.transactions.createTransaction(r,u,n,s??++d.nonce,a,w),B=nearApiJs.utils.serialize.serialize(nearApiJs.transactions.SCHEMA.Transaction,h),N=await p.signMessage(B,r,c.connection.networkId),W=new nearApiJs.transactions.SignedTransaction({transaction:h,signature:new nearApiJs.transactions.Signature({keyType:h.publicKey.keyType,data:N.signature})}),{transaction:Y}=await c.connection.provider.sendTransactionUntil(W,"INCLUDED_FINAL"),V=Y.hash;if(!V)throw new Error("No transaction hash found");return await viem.withRetry(async()=>{let dt=await c.connection.provider.txStatus(V,r,i.until);if(dt)return dt;throw new Error("Transaction not found")},{retryCount:i.retryCount,delay:i.delay})};var l=class extends x{constructor({networkId:t,contractId:e,accountId:n=U,keypair:a=crypto$1.KeyPair.fromRandom("ed25519"),rootPublicKey:s,sendTransactionOptions:i}){super(),this.networkId=t,this.contractId=e,this.accountId=n,this.keypair=a,this.sendTransactionOptions=i,this.rootPublicKey=s||Pt(this.contractId);}async getContract(){let t=await I({networkId:this.networkId,accountId:this.accountId,keypair:this.keypair});return new accounts.Contract(t,this.contractId,{viewMethods:["public_key","experimental_signature_deposit","derived_public_key"],changeMethods:[],useLocalViewExecution:false})}async getCurrentSignatureDeposit(){let t=await this.getContract();return new te__default.default((await t.experimental_signature_deposit()).toLocaleString("fullwide",{useGrouping:false}))}async getDerivedPublicKey(t){if(t.IsEd25519)return await(await this.getContract()).derived_public_key({path:t.path,predecessor:t.predecessor,domain_id:1});if(this.rootPublicKey)return y.deriveChildPublicKey(await this.getPublicKey(),t.predecessor.toLowerCase(),t.path,E);{let n=await(await this.getContract()).derived_public_key(t);return v(n)}}async getPublicKey(){if(this.rootPublicKey)return v(this.rootPublicKey);{let e=await(await this.getContract()).public_key();return v(e)}}async sign(t,e){this.requireAccount();let n=await this.getCurrentSignatureDeposit(),a=await st({accountId:this.accountId,keypair:this.keypair,networkId:this.networkId,receiverId:this.contractId,actions:[transactions.actionCreators.functionCall("sign",{request:t},BigInt(L.toString()),BigInt(n.toString()))],nonce:e?.nonce,options:this.sendTransactionOptions}),s=at({response:a});if(!s)throw new Error("Transaction failed");return s}requireAccount(){if(this.accountId===U)throw new Error("A valid account ID and keypair are required for change methods. Please instantiate a new contract with valid credentials.")}};var fe=async(r,t)=>{try{let e=await I({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new l({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new A.EVM({publicClient:viem.createPublicClient({transport:viem.http(r.chainConfig.providerUrl)}),contract:n}),{transaction:s,hashesToSign:i}=await a.prepareTransactionForSigning(r.transaction),o=await n.sign({payload:i[0],path:r.derivationPath,key_version:0}),c=a.finalizeTransactionSigning({transaction:s,rsvSignatures:[o]});return {transactionHash:(await a.broadcastTx(c)).hash,success:!0}}catch(e){return console.error(e),{success:false,errorMessage:e instanceof Error?e.message:String(e)}}},be=async(r,t)=>{try{let e=await I({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new l({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new k.Bitcoin({btcRpcAdapter:new $.Mempool(r.chainConfig.providerUrl),contract:n,network:r.chainConfig.network}),{transaction:s,hashesToSign:i}=await a.prepareTransactionForSigning(r.transaction),o=await Promise.all(i.map(async u=>await n.sign({payload:u,path:r.derivationPath,key_version:0}))),c=a.finalizeTransactionSigning({transaction:s,rsvSignatures:o});return {transactionHash:(await a.broadcastTx(c)).hash,success:!0}}catch(e){return {success:false,errorMessage:e instanceof Error?e.message:String(e)}}},Te=async(r,t)=>{try{let e=await I({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new l({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new R.Cosmos({contract:n,chainId:r.chainConfig.chainId}),{transaction:s,hashesToSign:i}=await a.prepareTransactionForSigning(r.transaction),o=await Promise.all(i.map(async u=>await n.sign({payload:u,path:r.derivationPath,key_version:0}))),c=a.finalizeTransactionSigning({transaction:s,rsvSignatures:o});return {transactionHash:await a.broadcastTx(c),success:!0}}catch(e){return console.error(e),{success:false,errorMessage:e instanceof Error?e.message:String(e)}}};var Se={transaction:it,signAndSend:ct};
exports.chainAdapters=nt;exports.constants=ut;exports.contracts=It;exports.utils=mt;//# sourceMappingURL=index.node.cjs.map
//# sourceMappingURL=index.node.cjs.map