import {base58}from'@scure/base';import {ec}from'elliptic';import {sha3_256}from'js-sha3';import Kt from'bn.js';import {concatHex,numberToHex,keccak256,getAddress,serializeTransaction,parseTransaction,toBytes,hashMessage,hashTypedData,encodeAbiParameters,hexToBigInt,concat,pad,isAddress,withRetry,createPublicClient,http}from'viem';import*as f from'bitcoinjs-lib';import Dt from'coinselect';import {encodeSecp256k1Pubkey}from'@cosmjs/amino';import {sha256,ripemd160}from'@cosmjs/crypto';import {fromHex,toBase64,fromBase64}from'@cosmjs/encoding';import {Registry,encodePubkey,makeAuthInfoBytes,makeSignDoc,makeSignBytes}from'@cosmjs/proto-signing';import {calculateFee,GasPrice,StargateClient}from'@cosmjs/stargate';import {bech32}from'bech32';import {SignMode}from'cosmjs-types/cosmos/tx/signing/v1beta1/signing';import {TxRaw}from'cosmjs-types/cosmos/tx/v1beta1/tx';import {chains,assets}from'chain-registry';import {PublicKey,Transaction,SystemProgram}from'@solana/web3.js';import {Contract,Connection,Account}from'@near-js/accounts';import {KeyPair}from'@near-js/crypto';import {InMemoryKeyStore}from'@near-js/keystores';import {actionCreators}from'@near-js/transactions';import {connect,utils,transactions}from'near-api-js';import {getTransactionLastResult}from'near-api-js/lib/providers';var Bt=Object.defineProperty;var m=(r,t)=>{for(var e in t)Bt(r,e,{get:t[e],enumerable:true});};var dt={};m(dt,{CONTRACT_ADDRESSES:()=>J,ENVS:()=>b,KDF_CHAIN_ID:()=>It,ROOT_PUBLIC_KEYS:()=>Y});var b={TESTNET_DEV:"TESTNET_DEV",TESTNET:"TESTNET",MAINNET:"MAINNET"},Y={[b.TESTNET_DEV]:"secp256k1:placeholder",[b.TESTNET]:"secp256k1:4NfTiv3UsGahebgTaHyD9vF8KYKMBnfd6kh94mK6xv8fGBiJB8TBtFMP5WWXz6B89Ac1fbpzPwAvoyQebemHFwx3",[b.MAINNET]:"secp256k1:3tFRbMqmoa6AAALMrEFAYCEoHcqKxeW38YptwowBVBtXK1vo36HDbUWuR6EZmoK4JcH6HDkNMGGqP1ouV7VZUWya"},It="0x18d",J={[b.TESTNET_DEV]:"v1.signer",[b.TESTNET]:"v1.signer-prod.testnet",[b.MAINNET]:"v1.sig-net.near"};var ut={};m(ut,{cryptography:()=>y});var y={};m(y,{compressPubKey:()=>Rt,deriveChildPublicKey:()=>_t,najToUncompressedPubKeySEC1:()=>E,toRSV:()=>kt});var kt=r=>{if("big_r"in r&&typeof r.big_r=="object"&&"affine_point"in r.big_r&&"s"in r&&typeof r.s=="object"&&"scalar"in r.s)return {r:r.big_r.affine_point.substring(2),s:r.s.scalar,v:r.recovery_id+27};if("big_r"in r&&typeof r.big_r=="string"&&"s"in r&&typeof r.s=="string")return {r:r.big_r.substring(2),s:r.s,v:r.recovery_id+27};if("bigR"in r&&"x"in r.bigR&&"s"in r&&typeof r.s=="bigint")return {r:r.bigR.x.toString(16).padStart(64,"0"),s:r.s.toString(16).padStart(64,"0"),v:r.recoveryId+27};throw new Error("Invalid signature format")},Rt=r=>{let t=r.slice(2);if(t.length!==128)throw new Error("Invalid uncompressed public key length");let e=t.slice(0,64),n=t.slice(64);return (parseInt(n.slice(-1),16)%2===0?"02":"03")+e},E=r=>{let t=base58.decode(r.split(":")[1]);return `04${Buffer.from(t).toString("hex")}`};function _t(r,t,e=""){let n=new ec("secp256k1"),s=`near-mpc-recovery v0.1.0 epsilon derivation:${t},${e}`,i=sha3_256(s),o=new Kt(i,16),c=r.substring(2,66),p=r.substring(66),u=n.curve.point(c,p),d=n.g.mul(o),w=u.add(d),l=w.getX().toString("hex").padStart(64,"0"),I=w.getY().toString("hex").padStart(64,"0");return `04${l}${I}`}var et={};m(et,{ChainAdapter:()=>g,btc:()=>K,cosmos:()=>R,evm:()=>v,solana:()=>tt});var g=class{};var v={};m(v,{EVM:()=>H,fetchEVMFeeProperties:()=>V});async function V(r,t){let[e,n]=await Promise.all([r.estimateGas(t),r.estimateFeesPerGas()]),a=n.maxFeePerGas??BigInt(1e10),s=n.maxPriorityFeePerGas??BigInt(1e10);return {gas:e,maxFeePerGas:a,maxPriorityFeePerGas:s}}var H=class extends g{constructor({publicClient:t,contract:e}){super(),this.contract=e,this.client=t;}async attachGasAndNonce(t){let e=await V(this.client,t),n=await this.client.getTransactionCount({address:t.from}),{from:a,...s}=t;return {...e,nonce:n,chainId:Number(await this.client.getChainId()),type:"eip1559",...s}}transformRSVSignature(t){return {r:`0x${t.r}`,s:`0x${t.s}`,yParity:t.v-27}}assembleSignature(t){let{r:e,s:n,yParity:a}=this.transformRSVSignature(t);if(a===void 0)throw new Error("Missing yParity");return concatHex([e,n,numberToHex(a+27,{size:1})])}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let a=n.startsWith("04")?n.slice(2):n,s=keccak256(Buffer.from(a,"hex"));return {address:getAddress(`0x${s.slice(-40)}`),publicKey:n}}async getBalance(t){return {balance:await this.client.getBalance({address:t}),decimals:18}}serializeTransaction(t){return serializeTransaction(t)}deserializeTransaction(t){return parseTransaction(t)}async prepareTransactionForSigning(t){let e=await this.attachGasAndNonce(t),n=serializeTransaction(e),a=toBytes(keccak256(n));return {transaction:e,hashesToSign:[Array.from(a)]}}async prepareMessageForSigning(t){return {hashToSign:Array.from(toBytes(hashMessage(t)))}}async prepareTypedDataForSigning(t){return {hashToSign:Array.from(toBytes(hashTypedData(t)))}}async prepareUserOpForSigning(t,e,n){let a=n??await this.client.getChainId(),s=e||"0x0000000071727De22E5E9d8BAf0edAc6f37da032",i=encodeAbiParameters([{type:"bytes32"},{type:"address"},{type:"uint256"}],[keccak256(encodeAbiParameters([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"}],[t.sender,hexToBigInt(t.nonce),keccak256("factory"in t&&"factoryData"in t&&t.factory&&t.factoryData?concat([t.factory,t.factoryData]):"initCode"in t?t.initCode:"0x"),keccak256(t.callData),concat([pad(t.verificationGasLimit,{size:16}),pad(t.callGasLimit,{size:16})]),hexToBigInt(t.preVerificationGas),concat([pad(t.maxPriorityFeePerGas,{size:16}),pad(t.maxFeePerGas,{size:16})]),keccak256("paymaster"in t&&t.paymaster&&isAddress(t.paymaster)?concat([t.paymaster,pad(t.paymasterVerificationGasLimit,{size:16}),pad(t.paymasterPostOpGasLimit,{size:16}),t.paymasterData]):"paymasterAndData"in t?t.paymasterAndData:"0x")])),s,BigInt(a)]),o=keccak256(i);return {userOp:t,hashToSign:Array.from(toBytes(hashMessage({raw:o})))}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){let n=this.transformRSVSignature(e[0]);return serializeTransaction(t,n)}finalizeMessageSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeTypedDataSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeUserOpSigning({userOp:t,rsvSignature:e}){let{r:n,s:a,yParity:s}=this.transformRSVSignature(e);if(s===void 0)throw new Error("Missing yParity");return {...t,signature:concatHex(["0x00",n,a,numberToHex(Number(s+27),{size:1})])}}async broadcastTx(t){try{return {hash:await this.client.sendRawTransaction({serializedTransaction:t})}}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var K={};m(K,{BTCRpcAdapter:()=>S,BTCRpcAdapters:()=>z,Bitcoin:()=>O});function Z(r){switch(r.toLowerCase()){case "mainnet":return f.networks.bitcoin;case "testnet":return f.networks.testnet;case "regtest":return f.networks.regtest;default:throw new Error(`Unknown Bitcoin network: ${r}`)}}var O=class r extends g{static{this.SATOSHIS_PER_BTC=1e8;}constructor({network:t,contract:e,btcRpcAdapter:n}){super(),this.network=t,this.btcRpcAdapter=n,this.contract=e;}static toBTC(t){return t/r.SATOSHIS_PER_BTC}static toSatoshi(t){return Math.round(t*r.SATOSHIS_PER_BTC)}async fetchTransaction(t){let e=await this.btcRpcAdapter.getTransaction(t),n=new f.Transaction;return e.vout.forEach(a=>{let s=Buffer.from(a.scriptpubkey,"hex");n.addOutput(s,Number(a.value));}),n}static transformRSVSignature(t){let e=t.r.padStart(64,"0"),n=t.s.padStart(64,"0"),a=Buffer.from(e+n,"hex");if(a.length!==64)throw new Error("Invalid signature length.");return a}async createPSBT({transactionRequest:t}){let{inputs:e,outputs:n}=t.inputs&&t.outputs?t:await this.btcRpcAdapter.selectUTXOs(t.from,[{address:t.to,value:parseFloat(t.value)}]),a=new f.Psbt({network:Z(this.network)});return await Promise.all(e.map(async s=>{if(!s.scriptPubKey){let o=(await this.fetchTransaction(s.txid)).outs[s.vout];s.scriptPubKey=o.script;}a.addInput({hash:s.txid,index:s.vout,witnessUtxo:{script:s.scriptPubKey,value:s.value}});})),n.forEach(s=>{"address"in s?a.addOutput({address:s.address,value:s.value}):"script"in s?a.addOutput({script:s.script,value:s.value}):t.from!==void 0&&a.addOutput({value:Number(s.value),address:t.from});}),a}async getBalance(t){return {balance:BigInt(await this.btcRpcAdapter.getBalance(t)),decimals:8}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let a=y.compressPubKey(n),s=Buffer.from(a,"hex"),i=Z(this.network),o=f.payments.p2wpkh({pubkey:s,network:i}),{address:c}=o;if(!c)throw new Error("Failed to generate Bitcoin address");return {address:c,publicKey:a}}serializeTransaction(t){return JSON.stringify({psbt:t.psbt.toHex(),publicKey:t.publicKey})}deserializeTransaction(t){let e=JSON.parse(t);return {psbt:f.Psbt.fromHex(e.psbt),publicKey:e.publicKey}}async prepareTransactionForSigning(t){let e=Buffer.from(t.publicKey,"hex"),n=await this.createPSBT({transactionRequest:t}),a=n.toHex(),s=[],i=o=>({publicKey:e,sign:c=>(s[o]=Array.from(c),Buffer.alloc(64))});for(let o=0;o<n.inputCount;o++)n.signInput(o,i(o));return {transaction:{psbt:f.Psbt.fromHex(a),publicKey:t.publicKey},hashesToSign:s}}finalizeTransactionSigning({transaction:{psbt:t,publicKey:e},rsvSignatures:n}){let a=Buffer.from(e,"hex"),s=i=>({publicKey:a,sign:()=>{let o=n[i];return r.transformRSVSignature(o)}});for(let i=0;i<t.inputCount;i++)t.signInput(i,s(i));return t.finalizeAllInputs(),t.extractTransaction().toHex()}async broadcastTx(t){return {hash:await this.btcRpcAdapter.broadcastTransaction(t)}}};var S=class{};var A=class extends S{constructor(t){super(),this.providerUrl=t;}async fetchFeeRate(t=6){let n=await(await fetch(`${this.providerUrl}/v1/fees/recommended`)).json();return t<=1?n.fastestFee:t<=3?n.halfHourFee:t<=6?n.hourFee:n.economyFee}async fetchUTXOs(t){try{return await(await fetch(`${this.providerUrl}/address/${t}/utxo`)).json()}catch(e){return console.error("Failed to fetch UTXOs:",e),[]}}async selectUTXOs(t,e,n=6){let a=await this.fetchUTXOs(t),s=await this.fetchFeeRate(n),i=Dt(a,e,Math.ceil(s+1));if(!i.inputs||!i.outputs)throw new Error("Invalid transaction: coinselect failed to find a suitable set of inputs and outputs. This could be due to insufficient funds, or no inputs being available that meet the criteria.");return {inputs:i.inputs,outputs:i.outputs}}async broadcastTransaction(t){let e=await fetch(`${this.providerUrl}/tx`,{method:"POST",body:t});if(e.ok)return await e.text();throw new Error(`Failed to broadcast transaction: ${await e.text()}`)}async getBalance(t){let n=await(await fetch(`${this.providerUrl}/address/${t}`)).json();return n.chain_stats.funded_txo_sum-n.chain_stats.spent_txo_sum}async getTransaction(t){return await(await fetch(`${this.providerUrl}/tx/${t}`)).json()}};var z={Mempool:A};var R={};m(R,{Cosmos:()=>j});var ft=async r=>{let t=chains.find(d=>d.chain_id===r);if(!t)throw new Error(`Chain info not found for chainId: ${r}`);let{bech32_prefix:e,chain_id:n}=t,a=t.staking?.staking_tokens?.[0]?.denom,s=t.apis?.rpc?.[0]?.address,i=t.apis?.rest?.[0]?.address,o=t.fees?.fee_tokens?.[0]?.average_gas_price;if(!e||!a||!s||!i||!n||o===void 0)throw new Error(`Missing required chain information for ${t.chain_name}`);let p=assets.find(d=>d.chain_name===t.chain_name)?.assets.find(d=>d.base===a),u=p?.denom_units.find(d=>d.denom===p.display)?.exponent;if(u===void 0)throw new Error(`Could not find decimals for ${a} on chain ${t.chain_name}`);return {prefix:e,denom:a,rpcUrl:s,restUrl:i,expectedChainId:n,gasPrice:o,decimals:u}};var j=class extends g{constructor({chainId:t,contract:e,endpoints:n}){super(),this.contract=e,this.registry=new Registry,this.chainId=t,this.endpoints=n;}transformRSVSignature(t){return new Uint8Array([...fromHex(t.r),...fromHex(t.s)])}async getChainInfo(){return {...await ft(this.chainId),...this.endpoints}}async getBalance(t){try{let{restUrl:e,denom:n,decimals:a}=await this.getChainInfo(),s=await fetch(`${e}/cosmos/bank/v1beta1/balances/${t}`);if(!s.ok)throw new Error(`HTTP error! status: ${s.status}`);let c=(await s.json()).balances.find(p=>p.denom===n)?.amount??"0";return {balance:BigInt(c),decimals:a}}catch(e){throw console.error("Failed to fetch Cosmos balance:",e),new Error("Failed to fetch Cosmos balance")}}async deriveAddressAndPublicKey(t,e){let{prefix:n}=await this.getChainInfo(),a=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!a)throw new Error("Failed to get derived public key");let s=y.compressPubKey(a),i=sha256(fromHex(s)),o=ripemd160(i);return {address:bech32.encode(n,bech32.toWords(o)),publicKey:s}}serializeTransaction(t){let e=TxRaw.encode(t).finish();return toBase64(e)}deserializeTransaction(t){return TxRaw.decode(fromBase64(t))}async prepareTransactionForSigning(t){let{denom:e,rpcUrl:n,gasPrice:a}=await this.getChainInfo(),s=fromHex(t.publicKey),i=t.gas||2e5,o=calculateFee(i,GasPrice.fromString(`${a}${e}`)),p=await(await StargateClient.connect(n)).getAccount(t.address);if(!p)throw new Error(`Account ${t.address} does not exist on chain`);let{accountNumber:u,sequence:d}=p,w={typeUrl:"/cosmos.tx.v1beta1.TxBody",value:{messages:t.messages,memo:t.memo||""}},l=this.registry.encode(w),I=encodePubkey(encodeSecp256k1Pubkey(s)),U=makeAuthInfoBytes([{pubkey:I,sequence:d}],o.amount,Number(o.gas),void 0,void 0,SignMode.SIGN_MODE_DIRECT),X=makeSignDoc(l,U,this.chainId,u),W=makeSignBytes(X),N=Array.from(sha256(W));return {transaction:TxRaw.fromPartial({bodyBytes:l,authInfoBytes:U,signatures:[]}),hashesToSign:[N]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){t.signatures=e.map(a=>this.transformRSVSignature(a));let n=TxRaw.encode(t).finish();return Buffer.from(n).toString("hex")}async broadcastTx(t){try{let{rpcUrl:e}=await this.getChainInfo(),n=await StargateClient.connect(e),a=fromHex(t),s=await n.broadcastTx(a);if(s.code!==0)throw new Error(`Broadcast error: ${s.rawLog}`);return s.transactionHash}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var tt={};m(tt,{Solana:()=>Q});var te=r=>typeof r=="bigint"?r:BigInt(r.toString()),Q=class extends g{constructor(t){super(),this.connection=t.solanaConnection,this.contract=t.contract;}async getBalance(t){let e=new PublicKey(t),n=await this.connection.getBalance(e);return {balance:BigInt(n),decimals:9}}async deriveAddressAndPublicKey(t,e){let a=(await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true})).replace("ed25519:",""),s=new PublicKey(a);return {address:s.toBase58(),publicKey:s.toString()}}serializeTransaction(t){return Buffer.from(t.transaction.serialize({requireAllSignatures:false})).toString("base64")}deserializeTransaction(t){let e=Buffer.from(t,"base64"),n=Transaction.from(e);return {transaction:n,feePayer:n.feePayer||new PublicKey("11111111111111111111111111111111"),recentBlockhash:n.recentBlockhash||""}}async prepareTransactionForSigning(t){let e=new Transaction,n=te(t.amount);n>0n&&e.add(SystemProgram.transfer({fromPubkey:new PublicKey(t.from),toPubkey:new PublicKey(t.to),lamports:Number(n)})),t.instructions&&e.add(...t.instructions);let{blockhash:a}=await this.connection.getLatestBlockhash();e.recentBlockhash=a,e.feePayer=t.feePayer||new PublicKey(t.from);let s=e.compileMessage().serialize();return {transaction:{transaction:e,feePayer:e.feePayer,recentBlockhash:a},hashesToSign:[Array.from(s)]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e,senderAddress:n}){let a=Buffer.from(e.signature);return t.addSignature(new PublicKey(n),a),t.serialize().toString("base64")}async broadcastTx(t){let e=this.deserializeTransaction(t);return {hash:await this.connection.sendRawTransaction(e.transaction.serialize())}}};var xt={};m(xt,{ChainSignatureContract:()=>x,near:()=>ct});var nt=class{},x=class extends nt{};var ct={};m(ct,{ChainSignatureContract:()=>h,utils:()=>Ce});var ot={};m(ot,{keypair:()=>it});var it={};m(it,{BTCTransaction:()=>Te,CosmosTransaction:()=>Se,EVMTransaction:()=>be});var G=new Kt("300000000000000"),_="dontcare";var B=async({networkId:r,accountId:t=_,keypair:e=KeyPair.fromRandom("ed25519")})=>{let n=new InMemoryKeyStore;await n.setKey(r,t,e);let a=Connection.fromConfig({networkId:r,provider:{type:"JsonRpcProvider",args:{url:{testnet:"https://rpc.testnet.near.org",mainnet:"https://rpc.mainnet.near.org"}[r]}},signer:{type:"InMemorySigner",keyStore:n}});return new Account(a,t)};var wt=r=>{let t=Object.entries(J).find(([e,n])=>n.toLowerCase()===r.toLowerCase())?.[0];if(t)return Y[t]};var st={};m(st,{mpcPayloadsToChainSigTransaction:()=>ue,responseToMpcSignature:()=>rt,sendTransactionUntil:()=>at});var ue=async({networkId:r,contractId:t,hashesToSign:e,path:n})=>{let s=await new h({networkId:r,contractId:t}).getCurrentSignatureDeposit();return {receiverId:t,actions:e.map(i=>({type:"FunctionCall",params:{methodName:"sign",args:{request:{payload:Array.from(i),path:n,key_version:0}},gas:G.div(new Kt(e.length)).toString(),deposit:s?.toString()||"1"}}))}},rt=({response:r})=>{let t=getTransactionLastResult(r);if(t)return y.toRSV(t)},at=async({accountId:r,keypair:t,networkId:e,receiverId:n,actions:a,nonce:s,options:i={until:"EXECUTED_OPTIMISTIC",retryCount:3,delay:5e3,nodeUrl:e==="testnet"?"https://test.rpc.fastnear.com":"https://free.rpc.fastnear.com"}})=>{let o=new InMemoryKeyStore;await o.setKey(e,r,t);let c=await connect({networkId:e,keyStore:o,nodeUrl:i.nodeUrl}),{signer:p}=c.connection,u=await p.getPublicKey(r,c.connection.networkId),d=await c.connection.provider.query(`access_key/${r}/${u.toString()}`,""),w=utils.serialize.base_decode(d.block_hash),l=transactions.createTransaction(r,u,n,s??++d.nonce,a,w),I=utils.serialize.serialize(transactions.SCHEMA.Transaction,l),U=await p.signMessage(I,r,c.connection.networkId),X=new transactions.SignedTransaction({transaction:l,signature:new transactions.Signature({keyType:l.publicKey.keyType,data:U.signature})}),{transaction:W}=await c.connection.provider.sendTransactionUntil(X,"INCLUDED_FINAL"),N=W.hash;if(!N)throw new Error("No transaction hash found");return await withRetry(async()=>{let pt=await c.connection.provider.txStatus(N,r,i.until);if(pt)return pt;throw new Error("Transaction not found")},{retryCount:i.retryCount,delay:i.delay})};var h=class extends x{constructor({networkId:t,contractId:e,accountId:n=_,keypair:a=KeyPair.fromRandom("ed25519"),rootPublicKey:s,sendTransactionOptions:i}){super(),this.networkId=t,this.contractId=e,this.accountId=n,this.keypair=a,this.sendTransactionOptions=i,this.rootPublicKey=s||wt(this.contractId);}async getContract(){let t=await B({networkId:this.networkId,accountId:this.accountId,keypair:this.keypair});return new Contract(t,this.contractId,{viewMethods:["public_key","experimental_signature_deposit","derived_public_key"],changeMethods:[],useLocalViewExecution:false})}async getCurrentSignatureDeposit(){let t=await this.getContract();return new Kt((await t.experimental_signature_deposit()).toLocaleString("fullwide",{useGrouping:false}))}async getDerivedPublicKey(t){if(t.IsEd25519)return await(await this.getContract()).derived_public_key({path:t.path,predecessor:t.predecessor,domain_id:1});if(this.rootPublicKey)return y.deriveChildPublicKey(await this.getPublicKey(),t.predecessor.toLowerCase(),t.path);{let n=await(await this.getContract()).derived_public_key(t);return E(n)}}async getPublicKey(){if(this.rootPublicKey)return E(this.rootPublicKey);{let e=await(await this.getContract()).public_key();return E(e)}}async sign(t,e){this.requireAccount();let n=await this.getCurrentSignatureDeposit(),a=await at({accountId:this.accountId,keypair:this.keypair,networkId:this.networkId,receiverId:this.contractId,actions:[actionCreators.functionCall("sign",{request:t},BigInt(G.toString()),BigInt(n.toString()))],nonce:e?.nonce,options:this.sendTransactionOptions}),s=rt({response:a});if(!s)throw new Error("Transaction failed");return s}requireAccount(){if(this.accountId===_)throw new Error("A valid account ID and keypair are required for change methods. Please instantiate a new contract with valid credentials.")}};var be=async(r,t)=>{try{let e=await B({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new h({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new v.EVM({publicClient:createPublicClient({transport:http(r.chainConfig.providerUrl)}),contract:n}),{transaction:s,hashesToSign:i}=await a.prepareTransactionForSigning(r.transaction),o=await n.sign({payload:i[0],path:r.derivationPath,key_version:0}),c=a.finalizeTransactionSigning({transaction:s,rsvSignatures:[o]});return {transactionHash:(await a.broadcastTx(c)).hash,success:!0}}catch(e){return console.error(e),{success:false,errorMessage:e instanceof Error?e.message:String(e)}}},Te=async(r,t)=>{try{let e=await B({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new h({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new K.Bitcoin({btcRpcAdapter:new z.Mempool(r.chainConfig.providerUrl),contract:n,network:r.chainConfig.network}),{transaction:s,hashesToSign:i}=await a.prepareTransactionForSigning(r.transaction),o=await Promise.all(i.map(async u=>await n.sign({payload:u,path:r.derivationPath,key_version:0}))),c=a.finalizeTransactionSigning({transaction:s,rsvSignatures:o});return {transactionHash:(await a.broadcastTx(c)).hash,success:!0}}catch(e){return {success:false,errorMessage:e instanceof Error?e.message:String(e)}}},Se=async(r,t)=>{try{let e=await B({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new h({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new R.Cosmos({contract:n,chainId:r.chainConfig.chainId}),{transaction:s,hashesToSign:i}=await a.prepareTransactionForSigning(r.transaction),o=await Promise.all(i.map(async u=>await n.sign({payload:u,path:r.derivationPath,key_version:0}))),c=a.finalizeTransactionSigning({transaction:s,rsvSignatures:o});return {transactionHash:await a.broadcastTx(c),success:!0}}catch(e){return console.error(e),{success:false,errorMessage:e instanceof Error?e.message:String(e)}}};var Ce={transaction:st,signAndSend:ot};
export{et as chainAdapters,dt as constants,xt as contracts,ut as utils};//# sourceMappingURL=index.node.js.map
//# sourceMappingURL=index.node.js.map