'use strict';var base=require('@scure/base'),elliptic=require('elliptic'),jsSha3=require('js-sha3'),viem=require('viem'),S=require('bitcoinjs-lib'),Wt=require('coinselect'),amino=require('@cosmjs/amino'),crypto=require('@cosmjs/crypto'),encoding=require('@cosmjs/encoding'),protoSigning=require('@cosmjs/proto-signing'),stargate=require('@cosmjs/stargate'),bech32=require('bech32'),signing=require('cosmjs-types/cosmos/tx/signing/v1beta1/signing'),tx=require('cosmjs-types/cosmos/tx/v1beta1/tx'),chainRegistry=require('chain-registry'),web3_js=require('@solana/web3.js'),accounts=require('@near-js/accounts'),crypto$1=require('@near-js/crypto'),keystores=require('@near-js/keystores'),ye=require('bn.js'),transactions=require('@near-js/transactions'),nearApiJs=require('near-api-js'),providers=require('near-api-js/lib/providers');require('viem/chains');function _interopDefault(e){return e&&e.__esModule?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var n=Object.create(null);if(e){Object.keys(e).forEach(function(k){if(k!=='default'){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:true,get:function(){return e[k]}});}})}n.default=e;return Object.freeze(n)}var S__namespace=/*#__PURE__*/_interopNamespace(S);var Wt__default=/*#__PURE__*/_interopDefault(Wt);var ye__default=/*#__PURE__*/_interopDefault(ye);var Vt=Object.defineProperty;var u=(r,t)=>{for(var e in t)Vt(r,e,{get:t[e],enumerable:true});};var wt={};u(wt,{CHAINS:()=>f,CONTRACT_ADDRESSES:()=>at,ENVS:()=>g,KDF_CHAIN_IDS:()=>T,ROOT_PUBLIC_KEYS:()=>rt});var g={TESTNET_DEV:"TESTNET_DEV",TESTNET:"TESTNET",MAINNET:"MAINNET"},f={ETHEREUM:"ETHEREUM",NEAR:"NEAR"},rt={[g.TESTNET_DEV]:"secp256k1:54hU5wcCmVUPFWLDALXMh1fFToZsVXrx9BbTbHzSfQq1Kd1rJZi52iPa4QQxo6s5TgjWqgpY8HamYuUDzG6fAaUq",[g.TESTNET]:"secp256k1:3Ww8iFjqTHufye5aRGUvrQqETegR4gVUcW8FX5xzscaN9ENhpkffojsxJwi6N1RbbHMTxYa9UyKeqK3fsMuwxjR5",[g.MAINNET]:"secp256k1:4tY4qMzusmgX5wYdG35663Y3Qar3CTbpApotwk9ZKLoF79XA4DjG8XoByaKdNHKQX9Lz5hd7iJqsWdTKyA7dKa6Z"},T={[f.ETHEREUM]:"0x1",[f.NEAR]:"0x18d"},at={[f.NEAR]:{[g.TESTNET_DEV]:"dev.sig-net.testnet",[g.TESTNET]:"v1.sig-net.testnet",[g.MAINNET]:"v1.sig-net.near"},[f.ETHEREUM]:{[g.TESTNET_DEV]:"0x69C6b28Fdc74618817fa380De29a653060e14009",[g.TESTNET]:"0x83458E8Bf8206131Fe5c05127007FA164c0948A2",[g.MAINNET]:"0xf8bdC0612361a1E49a8E01423d4C0cFc5dF4791A"}};var xt={};u(xt,{cryptography:()=>y});var y={};u(y,{compressPubKey:()=>$t,deriveChildPublicKey:()=>jt,najToUncompressedPubKeySEC1:()=>w,toRSV:()=>zt});var zt=r=>{if("big_r"in r&&typeof r.big_r=="object"&&"affine_point"in r.big_r&&"s"in r&&typeof r.s=="object"&&"scalar"in r.s)return {r:r.big_r.affine_point.substring(2),s:r.s.scalar,v:r.recovery_id+27};if("big_r"in r&&typeof r.big_r=="string"&&"s"in r&&typeof r.s=="string")return {r:r.big_r.substring(2),s:r.s,v:r.recovery_id+27};if("bigR"in r&&"x"in r.bigR&&"s"in r&&typeof r.s=="bigint")return {r:r.bigR.x.toString(16).padStart(64,"0"),s:r.s.toString(16).padStart(64,"0"),v:r.recoveryId+27};throw new Error("Invalid signature format")},$t=r=>{let t=r.slice(2);if(t.length!==128)throw new Error("Invalid uncompressed public key length");let e=t.slice(0,64),n=t.slice(64);return (parseInt(n.slice(-1),16)%2===0?"02":"03")+e},w=r=>{let t=base.base58.decode(r.split(":")[1]);return `04${Buffer.from(t).toString("hex")}`};function jt(r,t,e="",n){let a=new elliptic.ec("secp256k1"),s=`sig.network v1.0.0 epsilon derivation,${n},${t},${e}`,o="";if(n===T.ETHEREUM)o=viem.keccak256(Buffer.from(s)).slice(2);else if(n===T.NEAR)o=jsSha3.sha3_256(s);else throw new Error("Invalid chain ID");let c=r.substring(2,66),p=r.substring(66),m=a.curve.point(c,p),d=a.g.mul(o),v=m.add(d),b=v.getX().toString("hex").padStart(64,"0"),N=v.getY().toString("hex").padStart(64,"0");return `04${b}${N}`}var pt={};u(pt,{ChainAdapter:()=>l,btc:()=>M,cosmos:()=>D,evm:()=>_,solana:()=>ct});var l=class{};var _={};u(_,{EVM:()=>G,fetchEVMFeeProperties:()=>$});async function $(r,t){let[e,n]=await Promise.all([r.estimateGas(t),r.estimateFeesPerGas()]),a=n.maxFeePerGas??BigInt(1e10),i=n.maxPriorityFeePerGas??BigInt(1e10);return {gas:e,maxFeePerGas:a,maxPriorityFeePerGas:i}}var G=class extends l{constructor({publicClient:t,contract:e}){super(),this.contract=e,this.client=t;}async attachGasAndNonce(t){let e=await $(this.client,t),n=await this.client.getTransactionCount({address:t.from}),{from:a,...i}=t;return {...e,nonce:n,chainId:Number(await this.client.getChainId()),type:"eip1559",...i}}transformRSVSignature(t){return {r:`0x${t.r}`,s:`0x${t.s}`,yParity:t.v-27}}assembleSignature(t){let{r:e,s:n,yParity:a}=this.transformRSVSignature(t);if(a===void 0)throw new Error("Missing yParity");return viem.concatHex([e,n,viem.numberToHex(a+27,{size:1})])}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let a=n.startsWith("04")?n.slice(2):n,i=viem.keccak256(Buffer.from(a,"hex"));return {address:viem.getAddress(`0x${i.slice(-40)}`),publicKey:n}}async getBalance(t){return {balance:await this.client.getBalance({address:t}),decimals:18}}serializeTransaction(t){return viem.serializeTransaction(t)}deserializeTransaction(t){return viem.parseTransaction(t)}async prepareTransactionForSigning(t){let e=await this.attachGasAndNonce(t),n=viem.serializeTransaction(e),a=viem.toBytes(viem.keccak256(n));return {transaction:e,hashesToSign:[Array.from(a)]}}async prepareMessageForSigning(t){return {hashToSign:Array.from(viem.toBytes(viem.hashMessage(t)))}}async prepareTypedDataForSigning(t){return {hashToSign:Array.from(viem.toBytes(viem.hashTypedData(t)))}}async prepareUserOpForSigning(t,e,n){let a=n??await this.client.getChainId(),i=e||"0x0000000071727De22E5E9d8BAf0edAc6f37da032",s=viem.encodeAbiParameters([{type:"bytes32"},{type:"address"},{type:"uint256"}],[viem.keccak256(viem.encodeAbiParameters([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"}],[t.sender,viem.hexToBigInt(t.nonce),viem.keccak256("factory"in t&&"factoryData"in t&&t.factory&&t.factoryData?viem.concat([t.factory,t.factoryData]):"initCode"in t?t.initCode:"0x"),viem.keccak256(t.callData),viem.concat([viem.pad(t.verificationGasLimit,{size:16}),viem.pad(t.callGasLimit,{size:16})]),viem.hexToBigInt(t.preVerificationGas),viem.concat([viem.pad(t.maxPriorityFeePerGas,{size:16}),viem.pad(t.maxFeePerGas,{size:16})]),viem.keccak256("paymaster"in t&&t.paymaster&&viem.isAddress(t.paymaster)?viem.concat([t.paymaster,viem.pad(t.paymasterVerificationGasLimit,{size:16}),viem.pad(t.paymasterPostOpGasLimit,{size:16}),t.paymasterData]):"paymasterAndData"in t?t.paymasterAndData:"0x")])),i,BigInt(a)]),o=viem.keccak256(s);return {userOp:t,hashToSign:Array.from(viem.toBytes(viem.hashMessage({raw:o})))}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){let n=this.transformRSVSignature(e[0]);return viem.serializeTransaction(t,n)}finalizeMessageSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeTypedDataSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeUserOpSigning({userOp:t,rsvSignature:e}){let{r:n,s:a,yParity:i}=this.transformRSVSignature(e);if(i===void 0)throw new Error("Missing yParity");return {...t,signature:viem.concatHex(["0x00",n,a,viem.numberToHex(Number(i+27),{size:1})])}}async broadcastTx(t){try{return {hash:await this.client.sendRawTransaction({serializedTransaction:t})}}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var M={};u(M,{BTCRpcAdapter:()=>P,BTCRpcAdapters:()=>W,Bitcoin:()=>q});function st(r){switch(r.toLowerCase()){case "mainnet":return S__namespace.networks.bitcoin;case "testnet":return S__namespace.networks.testnet;case "regtest":return S__namespace.networks.regtest;default:throw new Error(`Unknown Bitcoin network: ${r}`)}}var q=class r extends l{static{this.SATOSHIS_PER_BTC=1e8;}constructor({network:t,contract:e,btcRpcAdapter:n}){super(),this.network=t,this.btcRpcAdapter=n,this.contract=e;}static toBTC(t){return t/r.SATOSHIS_PER_BTC}static toSatoshi(t){return Math.round(t*r.SATOSHIS_PER_BTC)}async fetchTransaction(t){let e=await this.btcRpcAdapter.getTransaction(t),n=new S__namespace.Transaction;return e.vout.forEach(a=>{let i=Buffer.from(a.scriptpubkey,"hex");n.addOutput(i,Number(a.value));}),n}static transformRSVSignature(t){let e=t.r.padStart(64,"0"),n=t.s.padStart(64,"0"),a=Buffer.from(e+n,"hex");if(a.length!==64)throw new Error("Invalid signature length.");return a}async createPSBT({transactionRequest:t}){let{inputs:e,outputs:n}=t.inputs&&t.outputs?t:await this.btcRpcAdapter.selectUTXOs(t.from,[{address:t.to,value:parseFloat(t.value)}]),a=new S__namespace.Psbt({network:st(this.network)});return await Promise.all(e.map(async i=>{if(!i.scriptPubKey){let o=(await this.fetchTransaction(i.txid)).outs[i.vout];i.scriptPubKey=o.script;}a.addInput({hash:i.txid,index:i.vout,witnessUtxo:{script:i.scriptPubKey,value:i.value}});})),n.forEach(i=>{"address"in i?a.addOutput({address:i.address,value:i.value}):"script"in i?a.addOutput({script:i.script,value:i.value}):t.from!==void 0&&a.addOutput({value:Number(i.value),address:t.from});}),a}async getBalance(t){return {balance:BigInt(await this.btcRpcAdapter.getBalance(t)),decimals:8}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let a=y.compressPubKey(n),i=Buffer.from(a,"hex"),s=st(this.network),o=S__namespace.payments.p2wpkh({pubkey:i,network:s}),{address:c}=o;if(!c)throw new Error("Failed to generate Bitcoin address");return {address:c,publicKey:a}}serializeTransaction(t){return JSON.stringify({psbt:t.psbt.toHex(),publicKey:t.publicKey})}deserializeTransaction(t){let e=JSON.parse(t);return {psbt:S__namespace.Psbt.fromHex(e.psbt),publicKey:e.publicKey}}async prepareTransactionForSigning(t){let e=Buffer.from(t.publicKey,"hex"),n=await this.createPSBT({transactionRequest:t}),a=n.toHex(),i=[],s=o=>({publicKey:e,sign:c=>(i[o]=Array.from(c),Buffer.alloc(64))});for(let o=0;o<n.inputCount;o++)n.signInput(o,s(o));return {transaction:{psbt:S__namespace.Psbt.fromHex(a),publicKey:t.publicKey},hashesToSign:i}}finalizeTransactionSigning({transaction:{psbt:t,publicKey:e},rsvSignatures:n}){let a=Buffer.from(e,"hex"),i=s=>({publicKey:a,sign:()=>{let o=n[s];return r.transformRSVSignature(o)}});for(let s=0;s<t.inputCount;s++)t.signInput(s,i(s));return t.finalizeAllInputs(),t.extractTransaction().toHex()}async broadcastTx(t){return {hash:await this.btcRpcAdapter.broadcastTransaction(t)}}};var P=class{};var U=class extends P{constructor(t){super(),this.providerUrl=t;}async fetchFeeRate(t=6){let n=await(await fetch(`${this.providerUrl}/v1/fees/recommended`)).json();return t<=1?n.fastestFee:t<=3?n.halfHourFee:t<=6?n.hourFee:n.economyFee}async fetchUTXOs(t){try{return await(await fetch(`${this.providerUrl}/address/${t}/utxo`)).json()}catch(e){return console.error("Failed to fetch UTXOs:",e),[]}}async selectUTXOs(t,e,n=6){let a=await this.fetchUTXOs(t),i=await this.fetchFeeRate(n),s=Wt__default.default(a,e,Math.ceil(i+1));if(!s.inputs||!s.outputs)throw new Error("Invalid transaction: coinselect failed to find a suitable set of inputs and outputs. This could be due to insufficient funds, or no inputs being available that meet the criteria.");return {inputs:s.inputs,outputs:s.outputs}}async broadcastTransaction(t){let e=await fetch(`${this.providerUrl}/tx`,{method:"POST",body:t});if(e.ok)return await e.text();throw new Error(`Failed to broadcast transaction: ${await e.text()}`)}async getBalance(t){let n=await(await fetch(`${this.providerUrl}/address/${t}`)).json();return n.chain_stats.funded_txo_sum-n.chain_stats.spent_txo_sum}async getTransaction(t){return await(await fetch(`${this.providerUrl}/tx/${t}`)).json()}};var W={Mempool:U};var D={};u(D,{Cosmos:()=>J});var Rt=async r=>{let t=chainRegistry.chains.find(d=>d.chain_id===r);if(!t)throw new Error(`Chain info not found for chainId: ${r}`);let{bech32_prefix:e,chain_id:n}=t,a=t.staking?.staking_tokens?.[0]?.denom,i=t.apis?.rpc?.[0]?.address,s=t.apis?.rest?.[0]?.address,o=t.fees?.fee_tokens?.[0]?.average_gas_price;if(!e||!a||!i||!s||!n||o===void 0)throw new Error(`Missing required chain information for ${t.chain_name}`);let p=chainRegistry.assets.find(d=>d.chain_name===t.chain_name)?.assets.find(d=>d.base===a),m=p?.denom_units.find(d=>d.denom===p.display)?.exponent;if(m===void 0)throw new Error(`Could not find decimals for ${a} on chain ${t.chain_name}`);return {prefix:e,denom:a,rpcUrl:i,restUrl:s,expectedChainId:n,gasPrice:o,decimals:m}};var J=class extends l{constructor({chainId:t,contract:e,endpoints:n}){super(),this.contract=e,this.registry=new protoSigning.Registry,this.chainId=t,this.endpoints=n;}transformRSVSignature(t){return new Uint8Array([...encoding.fromHex(t.r),...encoding.fromHex(t.s)])}async getChainInfo(){return {...await Rt(this.chainId),...this.endpoints}}async getBalance(t){try{let{restUrl:e,denom:n,decimals:a}=await this.getChainInfo(),i=await fetch(`${e}/cosmos/bank/v1beta1/balances/${t}`);if(!i.ok)throw new Error(`HTTP error! status: ${i.status}`);let c=(await i.json()).balances.find(p=>p.denom===n)?.amount??"0";return {balance:BigInt(c),decimals:a}}catch(e){throw console.error("Failed to fetch Cosmos balance:",e),new Error("Failed to fetch Cosmos balance")}}async deriveAddressAndPublicKey(t,e){let{prefix:n}=await this.getChainInfo(),a=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!a)throw new Error("Failed to get derived public key");let i=y.compressPubKey(a),s=crypto.sha256(encoding.fromHex(i)),o=crypto.ripemd160(s);return {address:bech32.bech32.encode(n,bech32.bech32.toWords(o)),publicKey:i}}serializeTransaction(t){let e=tx.TxRaw.encode(t).finish();return encoding.toBase64(e)}deserializeTransaction(t){return tx.TxRaw.decode(encoding.fromBase64(t))}async prepareTransactionForSigning(t){let{denom:e,rpcUrl:n,gasPrice:a}=await this.getChainInfo(),i=encoding.fromHex(t.publicKey),s=t.gas||2e5,o=stargate.calculateFee(s,stargate.GasPrice.fromString(`${a}${e}`)),p=await(await stargate.StargateClient.connect(n)).getAccount(t.address);if(!p)throw new Error(`Account ${t.address} does not exist on chain`);let{accountNumber:m,sequence:d}=p,v={typeUrl:"/cosmos.tx.v1beta1.TxBody",value:{messages:t.messages,memo:t.memo||""}},b=this.registry.encode(v),N=protoSigning.encodePubkey(amino.encodeSecp256k1Pubkey(i)),O=protoSigning.makeAuthInfoBytes([{pubkey:N,sequence:d}],o.amount,Number(o.gas),void 0,void 0,signing.SignMode.SIGN_MODE_DIRECT),et=protoSigning.makeSignDoc(b,O,this.chainId,m),nt=protoSigning.makeSignBytes(et),z=Array.from(crypto.sha256(nt));return {transaction:tx.TxRaw.fromPartial({bodyBytes:b,authInfoBytes:O,signatures:[]}),hashesToSign:[z]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){t.signatures=e.map(a=>this.transformRSVSignature(a));let n=tx.TxRaw.encode(t).finish();return Buffer.from(n).toString("hex")}async broadcastTx(t){try{let{rpcUrl:e}=await this.getChainInfo(),n=await stargate.StargateClient.connect(e),a=encoding.fromHex(t),i=await n.broadcastTx(a);if(i.code!==0)throw new Error(`Broadcast error: ${i.rawLog}`);return i.transactionHash}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var ct={};u(ct,{Solana:()=>ot});var de=r=>typeof r=="bigint"?r:BigInt(r.toString()),ot=class extends l{constructor(t){super(),this.connection=t.solanaConnection,this.contract=t.contract;}async getBalance(t){let e=new web3_js.PublicKey(t),n=await this.connection.getBalance(e);return {balance:BigInt(n),decimals:9}}async deriveAddressAndPublicKey(t,e){let a=(await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true})).replace("ed25519:",""),i=new web3_js.PublicKey(a);return {address:i.toBase58(),publicKey:i.toString()}}serializeTransaction(t){return Buffer.from(t.transaction.serialize({requireAllSignatures:false})).toString("base64")}deserializeTransaction(t){let e=Buffer.from(t,"base64"),n=web3_js.Transaction.from(e);return {transaction:n,feePayer:n.feePayer||new web3_js.PublicKey("11111111111111111111111111111111"),recentBlockhash:n.recentBlockhash||""}}async prepareTransactionForSigning(t){let e=new web3_js.Transaction,n=de(t.amount);n>0n&&e.add(web3_js.SystemProgram.transfer({fromPubkey:new web3_js.PublicKey(t.from),toPubkey:new web3_js.PublicKey(t.to),lamports:Number(n)})),t.instructions&&e.add(...t.instructions);let{blockhash:a}=await this.connection.getLatestBlockhash();e.recentBlockhash=a,e.feePayer=t.feePayer||new web3_js.PublicKey(t.from);let i=e.compileMessage().serialize();return {transaction:{transaction:e,feePayer:e.feePayer,recentBlockhash:a},hashesToSign:[Array.from(i)]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e,senderAddress:n}){let a=Buffer.from(e.signature);return t.addSignature(new web3_js.PublicKey(n),a),t.serialize().toString("base64")}async broadcastTx(t){let e=this.deserializeTransaction(t);return {hash:await this.connection.sendRawTransaction(e.transaction.serialize())}}};var Mt={};u(Mt,{ChainSignatureContract:()=>C,evm:()=>St,near:()=>ft});var ut=class{},C=class extends ut{};var ft={};u(ft,{ChainSignatureContract:()=>h,utils:()=>ke});var gt={};u(gt,{keypair:()=>lt});var lt={};u(lt,{BTCTransaction:()=>Be,CosmosTransaction:()=>Ke,EVMTransaction:()=>Re});var Q=new ye__default.default("300000000000000"),H="dontcare";var R=async({networkId:r,accountId:t=H,keypair:e=crypto$1.KeyPair.fromRandom("ed25519")})=>{let n=new keystores.InMemoryKeyStore;await n.setKey(r,t,e);let a=accounts.Connection.fromConfig({networkId:r,provider:{type:"JsonRpcProvider",args:{url:{testnet:"https://rpc.testnet.near.org",mainnet:"https://rpc.mainnet.near.org"}[r]}},signer:{type:"InMemorySigner",keyStore:n}});return new accounts.Account(a,t)};var Z=(r,t)=>{let e=Object.entries(at[t]).find(([n,a])=>a.toLowerCase()===r.toLowerCase())?.[0];if(e)return rt[e]};var mt={};u(mt,{mpcPayloadsToChainSigTransaction:()=>we,responseToMpcSignature:()=>dt,sendTransactionUntil:()=>yt});var we=async({networkId:r,contractId:t,hashesToSign:e,path:n})=>{let i=await new h({networkId:r,contractId:t}).getCurrentSignatureDeposit();return {receiverId:t,actions:e.map(s=>({type:"FunctionCall",params:{methodName:"sign",args:{request:{payload:Array.from(s),path:n,key_version:0}},gas:Q.div(new ye__default.default(e.length)).toString(),deposit:i?.toString()||"1"}}))}},dt=({response:r})=>{let t=providers.getTransactionLastResult(r);if(t)return y.toRSV(t)},yt=async({accountId:r,keypair:t,networkId:e,receiverId:n,actions:a,nonce:i,options:s={until:"EXECUTED_OPTIMISTIC",retryCount:3,delay:5e3,nodeUrl:e==="testnet"?"https://test.rpc.fastnear.com":"https://free.rpc.fastnear.com"}})=>{let o=new keystores.InMemoryKeyStore;await o.setKey(e,r,t);let c=await nearApiJs.connect({networkId:e,keyStore:o,nodeUrl:s.nodeUrl}),{signer:p}=c.connection,m=await p.getPublicKey(r,c.connection.networkId),d=await c.connection.provider.query(`access_key/${r}/${m.toString()}`,""),v=nearApiJs.utils.serialize.base_decode(d.block_hash),b=nearApiJs.transactions.createTransaction(r,m,n,i??++d.nonce,a,v),N=nearApiJs.utils.serialize.serialize(nearApiJs.transactions.SCHEMA.Transaction,b),O=await p.signMessage(N,r,c.connection.networkId),et=new nearApiJs.transactions.SignedTransaction({transaction:b,signature:new nearApiJs.transactions.Signature({keyType:b.publicKey.keyType,data:O.signature})}),{transaction:nt}=await c.connection.provider.sendTransactionUntil(et,"INCLUDED_FINAL"),z=nt.hash;if(!z)throw new Error("No transaction hash found");return await viem.withRetry(async()=>{let Ct=await c.connection.provider.txStatus(z,r,s.until);if(Ct)return Ct;throw new Error("Transaction not found")},{retryCount:s.retryCount,delay:s.delay})};var h=class extends C{constructor({networkId:t,contractId:e,accountId:n=H,keypair:a=crypto$1.KeyPair.fromRandom("ed25519"),rootPublicKey:i,sendTransactionOptions:s}){super(),this.networkId=t,this.contractId=e,this.accountId=n,this.keypair=a,this.sendTransactionOptions=s,this.rootPublicKey=i||Z(this.contractId,f.NEAR);}async getContract(){let t=await R({networkId:this.networkId,accountId:this.accountId,keypair:this.keypair});return new accounts.Contract(t,this.contractId,{viewMethods:["public_key","experimental_signature_deposit","derived_public_key"],changeMethods:[],useLocalViewExecution:false})}async getCurrentSignatureDeposit(){let t=await this.getContract();return new ye__default.default((await t.experimental_signature_deposit()).toLocaleString("fullwide",{useGrouping:false}))}async getDerivedPublicKey(t){if(t.IsEd25519)return await(await this.getContract()).derived_public_key({path:t.path,predecessor:t.predecessor,domain_id:1});if(this.rootPublicKey)return y.deriveChildPublicKey(await this.getPublicKey(),t.predecessor.toLowerCase(),t.path,T.NEAR);{let n=await(await this.getContract()).derived_public_key(t);return w(n)}}async getPublicKey(){if(this.rootPublicKey)return w(this.rootPublicKey);{let e=await(await this.getContract()).public_key();return w(e)}}async sign(t,e){this.requireAccount();let n=await this.getCurrentSignatureDeposit(),a=await yt({accountId:this.accountId,keypair:this.keypair,networkId:this.networkId,receiverId:this.contractId,actions:[transactions.actionCreators.functionCall("sign",{request:t},BigInt(Q.toString()),BigInt(n.toString()))],nonce:e?.nonce,options:this.sendTransactionOptions}),i=dt({response:a});if(!i)throw new Error("Transaction failed");return i}requireAccount(){if(this.accountId===H)throw new Error("A valid account ID and keypair are required for change methods. Please instantiate a new contract with valid credentials.")}};var Re=async(r,t)=>{try{let e=await R({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new h({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new _.EVM({publicClient:viem.createPublicClient({transport:viem.http(r.chainConfig.providerUrl)}),contract:n}),{transaction:i,hashesToSign:s}=await a.prepareTransactionForSigning(r.transaction),o=await n.sign({payload:s[0],path:r.derivationPath,key_version:0}),c=a.finalizeTransactionSigning({transaction:i,rsvSignatures:[o]});return {transactionHash:(await a.broadcastTx(c)).hash,success:!0}}catch(e){return console.error(e),{success:false,errorMessage:e instanceof Error?e.message:String(e)}}},Be=async(r,t)=>{try{let e=await R({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new h({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new M.Bitcoin({btcRpcAdapter:new W.Mempool(r.chainConfig.providerUrl),contract:n,network:r.chainConfig.network}),{transaction:i,hashesToSign:s}=await a.prepareTransactionForSigning(r.transaction),o=await Promise.all(s.map(async m=>await n.sign({payload:m,path:r.derivationPath,key_version:0}))),c=a.finalizeTransactionSigning({transaction:i,rsvSignatures:o});return {transactionHash:(await a.broadcastTx(c)).hash,success:!0}}catch(e){return {success:false,errorMessage:e instanceof Error?e.message:String(e)}}},Ke=async(r,t)=>{try{let e=await R({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new h({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new D.Cosmos({contract:n,chainId:r.chainConfig.chainId}),{transaction:i,hashesToSign:s}=await a.prepareTransactionForSigning(r.transaction),o=await Promise.all(s.map(async m=>await n.sign({payload:m,path:r.derivationPath,key_version:0}))),c=a.finalizeTransactionSigning({transaction:i,rsvSignatures:o});return {transactionHash:await a.broadcastTx(c),success:!0}}catch(e){return console.error(e),{success:false,errorMessage:e instanceof Error?e.message:String(e)}}};var ke={transaction:mt,signAndSend:gt};var St={};u(St,{ChainSignatureContract:()=>Tt,utils:()=>Ve});var ht={};u(ht,{abi:()=>I});var I=[{inputs:[{internalType:"address",name:"_mpc_network",type:"address"},{internalType:"uint256",name:"_signatureDeposit",type:"uint256"}],stateMutability:"nonpayable",type:"constructor"},{inputs:[],name:"AccessControlBadConfirmation",type:"error"},{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"bytes32",name:"neededRole",type:"bytes32"}],name:"AccessControlUnauthorizedAccount",type:"error"},{anonymous:false,inputs:[{indexed:true,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:true,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:true,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},{anonymous:false,inputs:[{indexed:true,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:true,internalType:"address",name:"account",type:"address"},{indexed:true,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},{anonymous:false,inputs:[{indexed:true,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:true,internalType:"address",name:"account",type:"address"},{indexed:true,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},{anonymous:false,inputs:[{indexed:true,internalType:"bytes32",name:"requestId",type:"bytes32"},{indexed:false,internalType:"address",name:"responder",type:"address"},{indexed:false,internalType:"string",name:"error",type:"string"}],name:"SignatureError",type:"event"},{anonymous:false,inputs:[{indexed:false,internalType:"address",name:"sender",type:"address"},{indexed:false,internalType:"bytes32",name:"payload",type:"bytes32"},{indexed:false,internalType:"uint32",name:"keyVersion",type:"uint32"},{indexed:false,internalType:"uint256",name:"deposit",type:"uint256"},{indexed:false,internalType:"uint256",name:"chainId",type:"uint256"},{indexed:false,internalType:"string",name:"path",type:"string"},{indexed:false,internalType:"string",name:"algo",type:"string"},{indexed:false,internalType:"string",name:"dest",type:"string"},{indexed:false,internalType:"string",name:"params",type:"string"}],name:"SignatureRequested",type:"event"},{anonymous:false,inputs:[{indexed:true,internalType:"bytes32",name:"requestId",type:"bytes32"},{indexed:false,internalType:"address",name:"responder",type:"address"},{components:[{components:[{internalType:"uint256",name:"x",type:"uint256"},{internalType:"uint256",name:"y",type:"uint256"}],internalType:"struct ChainSignatures.AffinePoint",name:"bigR",type:"tuple"},{internalType:"uint256",name:"s",type:"uint256"},{internalType:"uint8",name:"recoveryId",type:"uint8"}],indexed:false,internalType:"struct ChainSignatures.Signature",name:"signature",type:"tuple"}],name:"SignatureResponded",type:"event"},{anonymous:false,inputs:[{indexed:true,internalType:"address",name:"owner",type:"address"},{indexed:false,internalType:"uint256",name:"amount",type:"uint256"}],name:"Withdraw",type:"event"},{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},{inputs:[],name:"getSignatureDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"callerConfirmation",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{components:[{internalType:"bytes32",name:"requestId",type:"bytes32"},{components:[{components:[{internalType:"uint256",name:"x",type:"uint256"},{internalType:"uint256",name:"y",type:"uint256"}],internalType:"struct ChainSignatures.AffinePoint",name:"bigR",type:"tuple"},{internalType:"uint256",name:"s",type:"uint256"},{internalType:"uint8",name:"recoveryId",type:"uint8"}],internalType:"struct ChainSignatures.Signature",name:"signature",type:"tuple"}],internalType:"struct ChainSignatures.Response[]",name:"_responses",type:"tuple[]"}],name:"respond",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{components:[{internalType:"bytes32",name:"requestId",type:"bytes32"},{internalType:"string",name:"errorMessage",type:"string"}],internalType:"struct ChainSignatures.ErrorResponse[]",name:"_errors",type:"tuple[]"}],name:"respondError",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"}],name:"setSignatureDeposit",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{components:[{internalType:"bytes32",name:"payload",type:"bytes32"},{internalType:"string",name:"path",type:"string"},{internalType:"uint32",name:"keyVersion",type:"uint32"},{internalType:"string",name:"algo",type:"string"},{internalType:"string",name:"dest",type:"string"},{internalType:"string",name:"params",type:"string"}],internalType:"struct ChainSignatures.SignRequest",name:"_request",type:"tuple"}],name:"sign",outputs:[],stateMutability:"payable",type:"function"},{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"_amount",type:"uint256"},{internalType:"address",name:"_receiver",type:"address"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}];var bt={};u(bt,{ChainSignatureError:()=>B,SignatureContractError:()=>k,SignatureNotFoundError:()=>K,SigningError:()=>F});var B=class extends Error{constructor(t,e,n){super(t),this.name="ChainSignatureError",this.requestId=e,this.receipt=n;}},K=class extends B{constructor(t,e){super("Signature not found after maximum retries",t,e),this.name="SignatureNotFoundError";}},k=class extends B{constructor(t,e,n){super(`Signature error: ${t}`,e,n),this.name="SignatureContractError",this.errorCode=t;}},F=class extends B{constructor(t,e,n){super("Error signing request",t,e),this.name="SigningError",this.originalError=n;}};var Ut=r=>{let t=viem.encodeAbiParameters([{type:"address"},{type:"bytes"},{type:"string"},{type:"uint32"},{type:"uint256"},{type:"string"},{type:"string"},{type:"string"}],[r.address,r.payload,r.path,Number(r.keyVersion),r.chainId,r.algo,r.dest,r.params]);return viem.keccak256(t)};var Tt=class extends C{constructor(t){super(),this.publicClient=t.publicClient,this.walletClient=t.walletClient,this.contractAddress=t.contractAddress;let e=t.rootPublicKey||Z(this.contractAddress,f.ETHEREUM);if(!e)throw new Error("Invalid public key, please provide a valid root public key or contract address");this.rootPublicKey=e;}async getCurrentSignatureDeposit(){let t=await this.publicClient.readContract({address:this.contractAddress,abi:I,functionName:"getSignatureDeposit"});return new ye__default.default(t.toString())}async getDerivedPublicKey(t){if("IsEd25519"in t&&t.IsEd25519)throw new Error("Ed25519 not supported on EVM chains");return y.deriveChildPublicKey(await this.getPublicKey(),t.predecessor.toLowerCase(),t.path,T.ETHEREUM)}async getPublicKey(){return w(this.rootPublicKey)}async getLatestKeyVersion(){let t=await this.publicClient.readContract({address:this.contractAddress,abi:I,functionName:"latestKeyVersion"});return Number(t)}async sign(t,e={sign:{algo:"",dest:"",params:""},retry:{delay:5e3,retryCount:12}}){if(!this.walletClient?.account)throw new Error("Wallet client required for signing operations");let n={payload:`0x${Buffer.from(t.payload).toString("hex")}`,path:t.path,keyVersion:t.key_version,algo:e.sign.algo??"",dest:e.sign.dest??"",params:e.sign.params??""},a=this.getRequestId({...n,address:this.walletClient.account.address,chainId:this.publicClient.chain?.id?BigInt(this.publicClient.chain.id):0n}),i=await this.walletClient.writeContract({address:this.contractAddress,abi:I,chain:this.publicClient.chain,account:this.walletClient.account,functionName:"sign",args:[n],value:BigInt((await this.getCurrentSignatureDeposit()).toString())}),s=await this.publicClient.waitForTransactionReceipt({hash:i});try{let o=await viem.withRetry(async()=>{let c=await this.getSignatureFromEvents(a,s.blockNumber);if(c)return c;throw new Error("Signature not found yet")},{delay:e.retry.delay,retryCount:e.retry.retryCount,shouldRetry:({count:c,error:p})=>(console.log(`Retrying get signature: ${c}/${e.retry.retryCount}`),p.message==="Signature not found yet")});if(o)return o;{let c=await this.getErrorFromEvents(a,s.blockNumber);throw c?new k(c.error,a,s):new K(a,s)}}catch(o){throw o instanceof K||o instanceof k?o:new F(a,s,o instanceof Error?o:void 0)}}getRequestId(t){return Ut(t)}async getErrorFromEvents(t,e){let n=await this.publicClient.getContractEvents({address:this.contractAddress,abi:I,eventName:"SignatureError",args:{requestId:t},fromBlock:e,toBlock:"latest"});if(n.length>0){let{args:a}=n[n.length-1];return a}}async getSignatureFromEvents(t,e){let n=await this.publicClient.getContractEvents({address:this.contractAddress,abi:I,eventName:"SignatureResponded",args:{requestId:t},fromBlock:e,toBlock:"latest"});if(n.length>0){let{args:a}=n[n.length-1];return y.toRSV(a.signature)}}};var Ve={ChainSignaturesContractABI:ht,errors:bt};
exports.chainAdapters=pt;exports.constants=wt;exports.contracts=Mt;exports.utils=xt;//# sourceMappingURL=index.browser.cjs.map
//# sourceMappingURL=index.browser.cjs.map