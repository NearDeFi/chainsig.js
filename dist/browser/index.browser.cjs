'use strict';var base=require('@scure/base'),elliptic=require('elliptic'),jsSha3=require('js-sha3'),Et=require('bn.js'),viem=require('viem'),f=require('bitcoinjs-lib'),Nt=require('coinselect'),amino=require('@cosmjs/amino'),crypto=require('@cosmjs/crypto'),encoding=require('@cosmjs/encoding'),protoSigning=require('@cosmjs/proto-signing'),stargate=require('@cosmjs/stargate'),bech32=require('bech32'),signing=require('cosmjs-types/cosmos/tx/signing/v1beta1/signing'),tx=require('cosmjs-types/cosmos/tx/v1beta1/tx'),chainRegistry=require('chain-registry'),web3_js=require('@solana/web3.js'),accounts=require('@near-js/accounts'),crypto$1=require('@near-js/crypto'),keystores=require('@near-js/keystores'),transactions=require('@near-js/transactions'),nearApiJs=require('near-api-js'),providers=require('near-api-js/lib/providers');function _interopDefault(e){return e&&e.__esModule?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var n=Object.create(null);if(e){Object.keys(e).forEach(function(k){if(k!=='default'){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:true,get:function(){return e[k]}});}})}n.default=e;return Object.freeze(n)}var Et__default=/*#__PURE__*/_interopDefault(Et);var f__namespace=/*#__PURE__*/_interopNamespace(f);var Nt__default=/*#__PURE__*/_interopDefault(Nt);var Ct=Object.defineProperty;var m=(r,t)=>{for(var e in t)Ct(r,e,{get:t[e],enumerable:true});};var ot={};m(ot,{CONTRACT_ADDRESSES:()=>Y,ENVS:()=>T,KDF_CHAIN_ID:()=>Pt,ROOT_PUBLIC_KEYS:()=>W});var T={TESTNET_DEV:"TESTNET_DEV",TESTNET:"TESTNET",MAINNET:"MAINNET"},W={[T.TESTNET_DEV]:"secp256k1:placeholder",[T.TESTNET]:"secp256k1:4NfTiv3UsGahebgTaHyD9vF8KYKMBnfd6kh94mK6xv8fGBiJB8TBtFMP5WWXz6B89Ac1fbpzPwAvoyQebemHFwx3",[T.MAINNET]:"secp256k1:3tFRbMqmoa6AAALMrEFAYCEoHcqKxeW38YptwowBVBtXK1vo36HDbUWuR6EZmoK4JcH6HDkNMGGqP1ouV7VZUWya"},Pt="0x18d",Y={[T.TESTNET_DEV]:"v1.signer",[T.TESTNET]:"v1.signer-prod.testnet",[T.MAINNET]:"v1.sig-net.near"};var ct={};m(ct,{cryptography:()=>y});var y={};m(y,{compressPubKey:()=>kt,deriveChildPublicKey:()=>At,najToUncompressedPubKeySEC1:()=>B,toRSV:()=>vt});var vt=r=>{if("big_r"in r&&typeof r.big_r=="object"&&"affine_point"in r.big_r&&"s"in r&&typeof r.s=="object"&&"scalar"in r.s)return {r:r.big_r.affine_point.substring(2),s:r.s.scalar,v:r.recovery_id+27};if("big_r"in r&&typeof r.big_r=="string"&&"s"in r&&typeof r.s=="string")return {r:r.big_r.substring(2),s:r.s,v:r.recovery_id+27};if("bigR"in r&&"x"in r.bigR&&"s"in r&&typeof r.s=="bigint")return {r:r.bigR.x.toString(16).padStart(64,"0"),s:r.s.toString(16).padStart(64,"0"),v:r.recoveryId+27};throw new Error("Invalid signature format")},kt=r=>{let t=r.slice(2);if(t.length!==128)throw new Error("Invalid uncompressed public key length");let e=t.slice(0,64),n=t.slice(64);return (parseInt(n.slice(-1),16)%2===0?"02":"03")+e},B=r=>{let t=base.base58.decode(r.split(":")[1]);return `04${Buffer.from(t).toString("hex")}`};function At(r,t,e=""){let n=new elliptic.ec("secp256k1"),i=`near-mpc-recovery v0.1.0 epsilon derivation:${t},${e}`,s=jsSha3.sha3_256(i),o=new Et__default.default(s,16),c=r.substring(2,66),p=r.substring(66),u=n.curve.point(c,p),d=n.g.mul(o),C=u.add(d),l=C.getX().toString("hex").padStart(64,"0"),I=C.getY().toString("hex").padStart(64,"0");return `04${l}${I}`}var tt={};m(tt,{ChainAdapter:()=>g,btc:()=>k,cosmos:()=>K,evm:()=>E,solana:()=>Q});var g=class{};var E={};m(E,{EVM:()=>H,fetchEVMFeeProperties:()=>N});async function N(r,t){let[e,n]=await Promise.all([r.estimateGas(t),r.estimateFeesPerGas()]),a=n.maxFeePerGas??BigInt(1e10),i=n.maxPriorityFeePerGas??BigInt(1e10);return {gas:e,maxFeePerGas:a,maxPriorityFeePerGas:i}}var H=class extends g{constructor({publicClient:t,contract:e}){super(),this.contract=e,this.client=t;}async attachGasAndNonce(t){let e=await N(this.client,t),n=await this.client.getTransactionCount({address:t.from}),{from:a,...i}=t;return {...e,nonce:n,chainId:Number(await this.client.getChainId()),type:"eip1559",...i}}transformRSVSignature(t){return {r:`0x${t.r}`,s:`0x${t.s}`,yParity:t.v-27}}assembleSignature(t){let{r:e,s:n,yParity:a}=this.transformRSVSignature(t);if(a===void 0)throw new Error("Missing yParity");return viem.concatHex([e,n,viem.numberToHex(a+27,{size:1})])}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let a=n.startsWith("04")?n.slice(2):n,i=viem.keccak256(Buffer.from(a,"hex"));return {address:viem.getAddress(`0x${i.slice(-40)}`),publicKey:n}}async getBalance(t){return {balance:await this.client.getBalance({address:t}),decimals:18}}serializeTransaction(t){return viem.serializeTransaction(t)}deserializeTransaction(t){return viem.parseTransaction(t)}async prepareTransactionForSigning(t){let e=await this.attachGasAndNonce(t),n=viem.serializeTransaction(e),a=viem.toBytes(viem.keccak256(n));return {transaction:e,hashesToSign:[Array.from(a)]}}async prepareMessageForSigning(t){return {hashToSign:Array.from(viem.toBytes(viem.hashMessage(t)))}}async prepareTypedDataForSigning(t){return {hashToSign:Array.from(viem.toBytes(viem.hashTypedData(t)))}}async prepareUserOpForSigning(t,e,n){let a=n??await this.client.getChainId(),i=e||"0x0000000071727De22E5E9d8BAf0edAc6f37da032",s=viem.encodeAbiParameters([{type:"bytes32"},{type:"address"},{type:"uint256"}],[viem.keccak256(viem.encodeAbiParameters([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"}],[t.sender,viem.hexToBigInt(t.nonce),viem.keccak256("factory"in t&&"factoryData"in t&&t.factory&&t.factoryData?viem.concat([t.factory,t.factoryData]):"initCode"in t?t.initCode:"0x"),viem.keccak256(t.callData),viem.concat([viem.pad(t.verificationGasLimit,{size:16}),viem.pad(t.callGasLimit,{size:16})]),viem.hexToBigInt(t.preVerificationGas),viem.concat([viem.pad(t.maxPriorityFeePerGas,{size:16}),viem.pad(t.maxFeePerGas,{size:16})]),viem.keccak256("paymaster"in t&&t.paymaster&&viem.isAddress(t.paymaster)?viem.concat([t.paymaster,viem.pad(t.paymasterVerificationGasLimit,{size:16}),viem.pad(t.paymasterPostOpGasLimit,{size:16}),t.paymasterData]):"paymasterAndData"in t?t.paymasterAndData:"0x")])),i,BigInt(a)]),o=viem.keccak256(s);return {userOp:t,hashToSign:Array.from(viem.toBytes(viem.hashMessage({raw:o})))}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){let n=this.transformRSVSignature(e[0]);return viem.serializeTransaction(t,n)}finalizeMessageSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeTypedDataSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeUserOpSigning({userOp:t,rsvSignature:e}){let{r:n,s:a,yParity:i}=this.transformRSVSignature(e);if(i===void 0)throw new Error("Missing yParity");return {...t,signature:viem.concatHex(["0x00",n,a,viem.numberToHex(Number(i+27),{size:1})])}}async broadcastTx(t){try{return {hash:await this.client.sendRawTransaction({serializedTransaction:t})}}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var k={};m(k,{BTCRpcAdapter:()=>S,BTCRpcAdapters:()=>D,Bitcoin:()=>O});function q(r){switch(r.toLowerCase()){case "mainnet":return f__namespace.networks.bitcoin;case "testnet":return f__namespace.networks.testnet;case "regtest":return f__namespace.networks.regtest;default:throw new Error(`Unknown Bitcoin network: ${r}`)}}var O=class r extends g{static{this.SATOSHIS_PER_BTC=1e8;}constructor({network:t,contract:e,btcRpcAdapter:n}){super(),this.network=t,this.btcRpcAdapter=n,this.contract=e;}static toBTC(t){return t/r.SATOSHIS_PER_BTC}static toSatoshi(t){return Math.round(t*r.SATOSHIS_PER_BTC)}async fetchTransaction(t){let e=await this.btcRpcAdapter.getTransaction(t),n=new f__namespace.Transaction;return e.vout.forEach(a=>{let i=Buffer.from(a.scriptpubkey,"hex");n.addOutput(i,Number(a.value));}),n}static transformRSVSignature(t){let e=t.r.padStart(64,"0"),n=t.s.padStart(64,"0"),a=Buffer.from(e+n,"hex");if(a.length!==64)throw new Error("Invalid signature length.");return a}async createPSBT({transactionRequest:t}){let{inputs:e,outputs:n}=t.inputs&&t.outputs?t:await this.btcRpcAdapter.selectUTXOs(t.from,[{address:t.to,value:parseFloat(t.value)}]),a=new f__namespace.Psbt({network:q(this.network)});return await Promise.all(e.map(async i=>{if(!i.scriptPubKey){let o=(await this.fetchTransaction(i.txid)).outs[i.vout];i.scriptPubKey=o.script;}a.addInput({hash:i.txid,index:i.vout,witnessUtxo:{script:i.scriptPubKey,value:i.value}});})),n.forEach(i=>{"address"in i?a.addOutput({address:i.address,value:i.value}):"script"in i?a.addOutput({script:i.script,value:i.value}):t.from!==void 0&&a.addOutput({value:Number(i.value),address:t.from});}),a}async getBalance(t){return {balance:BigInt(await this.btcRpcAdapter.getBalance(t)),decimals:8}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let a=y.compressPubKey(n),i=Buffer.from(a,"hex"),s=q(this.network),o=f__namespace.payments.p2wpkh({pubkey:i,network:s}),{address:c}=o;if(!c)throw new Error("Failed to generate Bitcoin address");return {address:c,publicKey:a}}serializeTransaction(t){return JSON.stringify({psbt:t.psbt.toHex(),publicKey:t.publicKey})}deserializeTransaction(t){let e=JSON.parse(t);return {psbt:f__namespace.Psbt.fromHex(e.psbt),publicKey:e.publicKey}}async prepareTransactionForSigning(t){let e=Buffer.from(t.publicKey,"hex"),n=await this.createPSBT({transactionRequest:t}),a=n.toHex(),i=[],s=o=>({publicKey:e,sign:c=>(i[o]=Array.from(c),Buffer.alloc(64))});for(let o=0;o<n.inputCount;o++)n.signInput(o,s(o));return {transaction:{psbt:f__namespace.Psbt.fromHex(a),publicKey:t.publicKey},hashesToSign:i}}finalizeTransactionSigning({transaction:{psbt:t,publicKey:e},rsvSignatures:n}){let a=Buffer.from(e,"hex"),i=s=>({publicKey:a,sign:()=>{let o=n[s];return r.transformRSVSignature(o)}});for(let s=0;s<t.inputCount;s++)t.signInput(s,i(s));return t.finalizeAllInputs(),t.extractTransaction().toHex()}async broadcastTx(t){return {hash:await this.btcRpcAdapter.broadcastTransaction(t)}}};var S=class{};var v=class extends S{constructor(t){super(),this.providerUrl=t;}async fetchFeeRate(t=6){let n=await(await fetch(`${this.providerUrl}/v1/fees/recommended`)).json();return t<=1?n.fastestFee:t<=3?n.halfHourFee:t<=6?n.hourFee:n.economyFee}async fetchUTXOs(t){try{return await(await fetch(`${this.providerUrl}/address/${t}/utxo`)).json()}catch(e){return console.error("Failed to fetch UTXOs:",e),[]}}async selectUTXOs(t,e,n=6){let a=await this.fetchUTXOs(t),i=await this.fetchFeeRate(n),s=Nt__default.default(a,e,Math.ceil(i+1));if(!s.inputs||!s.outputs)throw new Error("Invalid transaction: coinselect failed to find a suitable set of inputs and outputs. This could be due to insufficient funds, or no inputs being available that meet the criteria.");return {inputs:s.inputs,outputs:s.outputs}}async broadcastTransaction(t){let e=await fetch(`${this.providerUrl}/tx`,{method:"POST",body:t});if(e.ok)return await e.text();throw new Error(`Failed to broadcast transaction: ${await e.text()}`)}async getBalance(t){let n=await(await fetch(`${this.providerUrl}/address/${t}`)).json();return n.chain_stats.funded_txo_sum-n.chain_stats.spent_txo_sum}async getTransaction(t){return await(await fetch(`${this.providerUrl}/tx/${t}`)).json()}};var D={Mempool:v};var K={};m(K,{Cosmos:()=>$});var yt=async r=>{let t=chainRegistry.chains.find(d=>d.chain_id===r);if(!t)throw new Error(`Chain info not found for chainId: ${r}`);let{bech32_prefix:e,chain_id:n}=t,a=t.staking?.staking_tokens?.[0]?.denom,i=t.apis?.rpc?.[0]?.address,s=t.apis?.rest?.[0]?.address,o=t.fees?.fee_tokens?.[0]?.average_gas_price;if(!e||!a||!i||!s||!n||o===void 0)throw new Error(`Missing required chain information for ${t.chain_name}`);let p=chainRegistry.assets.find(d=>d.chain_name===t.chain_name)?.assets.find(d=>d.base===a),u=p?.denom_units.find(d=>d.denom===p.display)?.exponent;if(u===void 0)throw new Error(`Could not find decimals for ${a} on chain ${t.chain_name}`);return {prefix:e,denom:a,rpcUrl:i,restUrl:s,expectedChainId:n,gasPrice:o,decimals:u}};var $=class extends g{constructor({chainId:t,contract:e,endpoints:n}){super(),this.contract=e,this.registry=new protoSigning.Registry,this.chainId=t,this.endpoints=n;}transformRSVSignature(t){return new Uint8Array([...encoding.fromHex(t.r),...encoding.fromHex(t.s)])}async getChainInfo(){return {...await yt(this.chainId),...this.endpoints}}async getBalance(t){try{let{restUrl:e,denom:n,decimals:a}=await this.getChainInfo(),i=await fetch(`${e}/cosmos/bank/v1beta1/balances/${t}`);if(!i.ok)throw new Error(`HTTP error! status: ${i.status}`);let c=(await i.json()).balances.find(p=>p.denom===n)?.amount??"0";return {balance:BigInt(c),decimals:a}}catch(e){throw console.error("Failed to fetch Cosmos balance:",e),new Error("Failed to fetch Cosmos balance")}}async deriveAddressAndPublicKey(t,e){let{prefix:n}=await this.getChainInfo(),a=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!a)throw new Error("Failed to get derived public key");let i=y.compressPubKey(a),s=crypto.sha256(encoding.fromHex(i)),o=crypto.ripemd160(s);return {address:bech32.bech32.encode(n,bech32.bech32.toWords(o)),publicKey:i}}serializeTransaction(t){let e=tx.TxRaw.encode(t).finish();return encoding.toBase64(e)}deserializeTransaction(t){return tx.TxRaw.decode(encoding.fromBase64(t))}async prepareTransactionForSigning(t){let{denom:e,rpcUrl:n,gasPrice:a}=await this.getChainInfo(),i=encoding.fromHex(t.publicKey),s=t.gas||2e5,o=stargate.calculateFee(s,stargate.GasPrice.fromString(`${a}${e}`)),p=await(await stargate.StargateClient.connect(n)).getAccount(t.address);if(!p)throw new Error(`Account ${t.address} does not exist on chain`);let{accountNumber:u,sequence:d}=p,C={typeUrl:"/cosmos.tx.v1beta1.TxBody",value:{messages:t.messages,memo:t.memo||""}},l=this.registry.encode(C),I=protoSigning.encodePubkey(amino.encodeSecp256k1Pubkey(i)),_=protoSigning.makeAuthInfoBytes([{pubkey:I,sequence:d}],o.amount,Number(o.gas),void 0,void 0,signing.SignMode.SIGN_MODE_DIRECT),L=protoSigning.makeSignDoc(l,_,this.chainId,u),X=protoSigning.makeSignBytes(L),U=Array.from(crypto.sha256(X));return {transaction:tx.TxRaw.fromPartial({bodyBytes:l,authInfoBytes:_,signatures:[]}),hashesToSign:[U]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){t.signatures=e.map(a=>this.transformRSVSignature(a));let n=tx.TxRaw.encode(t).finish();return Buffer.from(n).toString("hex")}async broadcastTx(t){try{let{rpcUrl:e}=await this.getChainInfo(),n=await stargate.StargateClient.connect(e),a=encoding.fromHex(t),i=await n.broadcastTx(a);if(i.code!==0)throw new Error(`Broadcast error: ${i.rawLog}`);return i.transactionHash}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var Q={};m(Q,{Solana:()=>Z});var qt=r=>typeof r=="bigint"?r:BigInt(r.toString()),Z=class extends g{constructor(t){super(),this.connection=t.solanaConnection,this.contract=t.contract;}async getBalance(t){let e=new web3_js.PublicKey(t),n=await this.connection.getBalance(e);return {balance:BigInt(n),decimals:9}}async deriveAddressAndPublicKey(t,e){let a=(await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true})).replace("ed25519:",""),i=new web3_js.PublicKey(a);return {address:i.toBase58(),publicKey:i.toString()}}serializeTransaction(t){return Buffer.from(t.transaction.serialize({requireAllSignatures:false})).toString("base64")}deserializeTransaction(t){let e=Buffer.from(t,"base64"),n=web3_js.Transaction.from(e);return {transaction:n,feePayer:n.feePayer||new web3_js.PublicKey("11111111111111111111111111111111"),recentBlockhash:n.recentBlockhash||""}}async prepareTransactionForSigning(t){let e=new web3_js.Transaction,n=qt(t.amount);n>0n&&e.add(web3_js.SystemProgram.transfer({fromPubkey:new web3_js.PublicKey(t.from),toPubkey:new web3_js.PublicKey(t.to),lamports:Number(n)})),t.instructions&&e.add(...t.instructions);let{blockhash:a}=await this.connection.getLatestBlockhash();e.recentBlockhash=a,e.feePayer=t.feePayer||new web3_js.PublicKey(t.from);let i=e.compileMessage().serialize();return {transaction:{transaction:e,feePayer:e.feePayer,recentBlockhash:a},hashesToSign:[Array.from(i)]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e,senderAddress:n}){let a=Buffer.from(e.signature);return t.addSignature(new web3_js.PublicKey(n),a),t.serialize().toString("base64")}async broadcastTx(t){let e=this.deserializeTransaction(t);return {hash:await this.connection.sendRawTransaction(e.transaction.serialize())}}};var wt={};m(wt,{ChainSignatureContract:()=>h,utils:()=>Te});var it={};m(it,{keypair:()=>at});var at={};m(at,{BTCTransaction:()=>le,CosmosTransaction:()=>fe,EVMTransaction:()=>he});var j=new Et__default.default("300000000000000"),R="dontcare";var x=async({networkId:r,accountId:t=R,keypair:e=crypto$1.KeyPair.fromRandom("ed25519")})=>{let n=new keystores.InMemoryKeyStore;await n.setKey(r,t,e);let a=accounts.Connection.fromConfig({networkId:r,provider:{type:"JsonRpcProvider",args:{url:{testnet:"https://rpc.testnet.near.org",mainnet:"https://rpc.mainnet.near.org"}[r]}},signer:{type:"InMemorySigner",keyStore:n}});return new accounts.Account(a,t)};var bt=r=>{let t=Object.entries(Y).find(([e,n])=>n.toLowerCase()===r.toLowerCase())?.[0];if(t)return W[t]};var rt={};m(rt,{mpcPayloadsToChainSigTransaction:()=>ce,responseToMpcSignature:()=>et,sendTransactionUntil:()=>nt});var ce=async({networkId:r,contractId:t,hashesToSign:e,path:n})=>{let i=await new h({networkId:r,contractId:t}).getCurrentSignatureDeposit();return {receiverId:t,actions:e.map(s=>({type:"FunctionCall",params:{methodName:"sign",args:{request:{payload:Array.from(s),path:n,key_version:0}},gas:j.div(new Et__default.default(e.length)).toString(),deposit:i?.toString()||"1"}}))}},et=({response:r})=>{let t=providers.getTransactionLastResult(r);if(t)return y.toRSV(t)},nt=async({accountId:r,keypair:t,networkId:e,receiverId:n,actions:a,nonce:i,options:s={until:"EXECUTED_OPTIMISTIC",retryCount:3,delay:5e3,nodeUrl:e==="testnet"?"https://test.rpc.fastnear.com":"https://free.rpc.fastnear.com"}})=>{let o=new keystores.InMemoryKeyStore;await o.setKey(e,r,t);let c=await nearApiJs.connect({networkId:e,keyStore:o,nodeUrl:s.nodeUrl}),{signer:p}=c.connection,u=await p.getPublicKey(r,c.connection.networkId),d=await c.connection.provider.query(`access_key/${r}/${u.toString()}`,""),C=nearApiJs.utils.serialize.base_decode(d.block_hash),l=nearApiJs.transactions.createTransaction(r,u,n,i??++d.nonce,a,C),I=nearApiJs.utils.serialize.serialize(nearApiJs.transactions.SCHEMA.Transaction,l),_=await p.signMessage(I,r,c.connection.networkId),L=new nearApiJs.transactions.SignedTransaction({transaction:l,signature:new nearApiJs.transactions.Signature({keyType:l.publicKey.keyType,data:_.signature})}),{transaction:X}=await c.connection.provider.sendTransactionUntil(L,"INCLUDED_FINAL"),U=X.hash;if(!U)throw new Error("No transaction hash found");return await viem.withRetry(async()=>{let st=await c.connection.provider.txStatus(U,r,s.until);if(st)return st;throw new Error("Transaction not found")},{retryCount:s.retryCount,delay:s.delay})};var h=class{constructor({networkId:t,contractId:e,accountId:n=R,keypair:a=crypto$1.KeyPair.fromRandom("ed25519"),rootPublicKey:i,sendTransactionOptions:s}){this.networkId=t,this.contractId=e,this.accountId=n,this.keypair=a,this.sendTransactionOptions=s,this.rootPublicKey=i||bt(this.contractId);}async getContract(){let t=await x({networkId:this.networkId,accountId:this.accountId,keypair:this.keypair});return new accounts.Contract(t,this.contractId,{viewMethods:["public_key","experimental_signature_deposit","derived_public_key"],changeMethods:[],useLocalViewExecution:false})}async getCurrentSignatureDeposit(){let t=await this.getContract();return new Et__default.default((await t.experimental_signature_deposit()).toLocaleString("fullwide",{useGrouping:false}))}async getDerivedPublicKey(t){if(t.IsEd25519)return await(await this.getContract()).derived_public_key({path:t.path,predecessor:t.predecessor,domain_id:1});if(this.rootPublicKey)return y.deriveChildPublicKey(await this.getPublicKey(),t.predecessor.toLowerCase(),t.path);{let n=await(await this.getContract()).derived_public_key(t);return B(n)}}async getPublicKey(){if(this.rootPublicKey)return B(this.rootPublicKey);{let e=await(await this.getContract()).public_key();return B(e)}}async sign(t,e){this.requireAccount();let n=await this.getCurrentSignatureDeposit(),a=await nt({accountId:this.accountId,keypair:this.keypair,networkId:this.networkId,receiverId:this.contractId,actions:[transactions.actionCreators.functionCall("sign",{request:t},BigInt(j.toString()),BigInt(n.toString()))],nonce:e?.nonce,options:this.sendTransactionOptions}),i=et({response:a});if(!i)throw new Error("Transaction failed");return i}requireAccount(){if(this.accountId===R)throw new Error("A valid account ID and keypair are required for change methods. Please instantiate a new contract with valid credentials.")}};var he=async(r,t)=>{try{let e=await x({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new h({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new E.EVM({publicClient:viem.createPublicClient({transport:viem.http(r.chainConfig.providerUrl)}),contract:n}),{transaction:i,hashesToSign:s}=await a.prepareTransactionForSigning(r.transaction),o=await n.sign({payload:s[0],path:r.derivationPath,key_version:0}),c=a.finalizeTransactionSigning({transaction:i,rsvSignatures:[o]});return {transactionHash:(await a.broadcastTx(c)).hash,success:!0}}catch(e){return console.error(e),{success:false,errorMessage:e instanceof Error?e.message:String(e)}}},le=async(r,t)=>{try{let e=await x({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new h({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new k.Bitcoin({btcRpcAdapter:new D.Mempool(r.chainConfig.providerUrl),contract:n,network:r.chainConfig.network}),{transaction:i,hashesToSign:s}=await a.prepareTransactionForSigning(r.transaction),o=await Promise.all(s.map(async u=>await n.sign({payload:u,path:r.derivationPath,key_version:0}))),c=a.finalizeTransactionSigning({transaction:i,rsvSignatures:o});return {transactionHash:(await a.broadcastTx(c)).hash,success:!0}}catch(e){return {success:false,errorMessage:e instanceof Error?e.message:String(e)}}},fe=async(r,t)=>{try{let e=await x({networkId:r.nearAuthentication.networkId,accountId:r.nearAuthentication.accountId,keypair:t}),n=new h({networkId:r.nearAuthentication.networkId,contractId:r.chainConfig.contract,accountId:e.accountId,keypair:t}),a=new K.Cosmos({contract:n,chainId:r.chainConfig.chainId}),{transaction:i,hashesToSign:s}=await a.prepareTransactionForSigning(r.transaction),o=await Promise.all(s.map(async u=>await n.sign({payload:u,path:r.derivationPath,key_version:0}))),c=a.finalizeTransactionSigning({transaction:i,rsvSignatures:o});return {transactionHash:await a.broadcastTx(c),success:!0}}catch(e){return console.error(e),{success:false,errorMessage:e instanceof Error?e.message:String(e)}}};var Te={transaction:rt,signAndSend:it};
exports.chainAdapters=tt;exports.constants=ot;exports.contracts=wt;exports.utils=ct;//# sourceMappingURL=index.browser.cjs.map
//# sourceMappingURL=index.browser.cjs.map